// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: direct.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_direct_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_direct_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_direct_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_direct_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_direct_2eproto;
namespace direct {
class CostRequest;
struct CostRequestDefaultTypeInternal;
extern CostRequestDefaultTypeInternal _CostRequest_default_instance_;
class CostResponse;
struct CostResponseDefaultTypeInternal;
extern CostResponseDefaultTypeInternal _CostResponse_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class DataRequest;
struct DataRequestDefaultTypeInternal;
extern DataRequestDefaultTypeInternal _DataRequest_default_instance_;
class DataResponse;
struct DataResponseDefaultTypeInternal;
extern DataResponseDefaultTypeInternal _DataResponse_default_instance_;
class InitRequest;
struct InitRequestDefaultTypeInternal;
extern InitRequestDefaultTypeInternal _InitRequest_default_instance_;
class InitResponse;
struct InitResponseDefaultTypeInternal;
extern InitResponseDefaultTypeInternal _InitResponse_default_instance_;
class MjModel;
struct MjModelDefaultTypeInternal;
extern MjModelDefaultTypeInternal _MjModel_default_instance_;
class Noise;
struct NoiseDefaultTypeInternal;
extern NoiseDefaultTypeInternal _Noise_default_instance_;
class NoiseRequest;
struct NoiseRequestDefaultTypeInternal;
extern NoiseRequestDefaultTypeInternal _NoiseRequest_default_instance_;
class NoiseResponse;
struct NoiseResponseDefaultTypeInternal;
extern NoiseResponseDefaultTypeInternal _NoiseResponse_default_instance_;
class OptimizeRequest;
struct OptimizeRequestDefaultTypeInternal;
extern OptimizeRequestDefaultTypeInternal _OptimizeRequest_default_instance_;
class OptimizeResponse;
struct OptimizeResponseDefaultTypeInternal;
extern OptimizeResponseDefaultTypeInternal _OptimizeResponse_default_instance_;
class ResetRequest;
struct ResetRequestDefaultTypeInternal;
extern ResetRequestDefaultTypeInternal _ResetRequest_default_instance_;
class ResetResponse;
struct ResetResponseDefaultTypeInternal;
extern ResetResponseDefaultTypeInternal _ResetResponse_default_instance_;
class SensorInfoRequest;
struct SensorInfoRequestDefaultTypeInternal;
extern SensorInfoRequestDefaultTypeInternal _SensorInfoRequest_default_instance_;
class SensorInfoResponse;
struct SensorInfoResponseDefaultTypeInternal;
extern SensorInfoResponseDefaultTypeInternal _SensorInfoResponse_default_instance_;
class Settings;
struct SettingsDefaultTypeInternal;
extern SettingsDefaultTypeInternal _Settings_default_instance_;
class SettingsRequest;
struct SettingsRequestDefaultTypeInternal;
extern SettingsRequestDefaultTypeInternal _SettingsRequest_default_instance_;
class SettingsResponse;
struct SettingsResponseDefaultTypeInternal;
extern SettingsResponseDefaultTypeInternal _SettingsResponse_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StatusRequest;
struct StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
}  // namespace direct
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace direct {

// ===================================================================


// -------------------------------------------------------------------

class StatusRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:direct.StatusRequest) */ {
 public:
  inline StatusRequest() : StatusRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusRequest(::google::protobuf::internal::ConstantInitialized);

  inline StatusRequest(const StatusRequest& from)
      : StatusRequest(nullptr, from) {}
  StatusRequest(StatusRequest&& from) noexcept
    : StatusRequest() {
    *this = ::std::move(from);
  }

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusRequest& operator=(StatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StatusRequest& a, StatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StatusRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StatusRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.StatusRequest";
  }
  protected:
  explicit StatusRequest(::google::protobuf::Arena* arena);
  StatusRequest(::google::protobuf::Arena* arena, const StatusRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:direct.StatusRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class Status final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Status(::google::protobuf::internal::ConstantInitialized);

  inline Status(const Status& from)
      : Status(nullptr, from) {}
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Status* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.Status";
  }
  protected:
  explicit Status(::google::protobuf::Arena* arena);
  Status(::google::protobuf::Arena* arena, const Status& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchIterationsFieldNumber = 1,
    kSmootherIterationsFieldNumber = 2,
    kStepSizeFieldNumber = 3,
    kRegularizationFieldNumber = 4,
    kGradientNormFieldNumber = 5,
    kSearchDirectionNormFieldNumber = 6,
    kCostDifferenceFieldNumber = 8,
    kImprovementFieldNumber = 9,
    kExpectedFieldNumber = 10,
    kReductionRatioFieldNumber = 11,
    kSolveStatusFieldNumber = 7,
  };
  // int32 search_iterations = 1;
  void clear_search_iterations() ;
  ::int32_t search_iterations() const;
  void set_search_iterations(::int32_t value);

  private:
  ::int32_t _internal_search_iterations() const;
  void _internal_set_search_iterations(::int32_t value);

  public:
  // int32 smoother_iterations = 2;
  void clear_smoother_iterations() ;
  ::int32_t smoother_iterations() const;
  void set_smoother_iterations(::int32_t value);

  private:
  ::int32_t _internal_smoother_iterations() const;
  void _internal_set_smoother_iterations(::int32_t value);

  public:
  // double step_size = 3;
  void clear_step_size() ;
  double step_size() const;
  void set_step_size(double value);

  private:
  double _internal_step_size() const;
  void _internal_set_step_size(double value);

  public:
  // double regularization = 4;
  void clear_regularization() ;
  double regularization() const;
  void set_regularization(double value);

  private:
  double _internal_regularization() const;
  void _internal_set_regularization(double value);

  public:
  // double gradient_norm = 5;
  void clear_gradient_norm() ;
  double gradient_norm() const;
  void set_gradient_norm(double value);

  private:
  double _internal_gradient_norm() const;
  void _internal_set_gradient_norm(double value);

  public:
  // double search_direction_norm = 6;
  void clear_search_direction_norm() ;
  double search_direction_norm() const;
  void set_search_direction_norm(double value);

  private:
  double _internal_search_direction_norm() const;
  void _internal_set_search_direction_norm(double value);

  public:
  // double cost_difference = 8;
  void clear_cost_difference() ;
  double cost_difference() const;
  void set_cost_difference(double value);

  private:
  double _internal_cost_difference() const;
  void _internal_set_cost_difference(double value);

  public:
  // double improvement = 9;
  void clear_improvement() ;
  double improvement() const;
  void set_improvement(double value);

  private:
  double _internal_improvement() const;
  void _internal_set_improvement(double value);

  public:
  // double expected = 10;
  void clear_expected() ;
  double expected() const;
  void set_expected(double value);

  private:
  double _internal_expected() const;
  void _internal_set_expected(double value);

  public:
  // double reduction_ratio = 11;
  void clear_reduction_ratio() ;
  double reduction_ratio() const;
  void set_reduction_ratio(double value);

  private:
  double _internal_reduction_ratio() const;
  void _internal_set_reduction_ratio(double value);

  public:
  // int32 solve_status = 7;
  void clear_solve_status() ;
  ::int32_t solve_status() const;
  void set_solve_status(::int32_t value);

  private:
  ::int32_t _internal_solve_status() const;
  void _internal_set_solve_status(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:direct.Status)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t search_iterations_;
    ::int32_t smoother_iterations_;
    double step_size_;
    double regularization_;
    double gradient_norm_;
    double search_direction_norm_;
    double cost_difference_;
    double improvement_;
    double expected_;
    double reduction_ratio_;
    ::int32_t solve_status_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class Settings final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.Settings) */ {
 public:
  inline Settings() : Settings(nullptr) {}
  ~Settings() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Settings(::google::protobuf::internal::ConstantInitialized);

  inline Settings(const Settings& from)
      : Settings(nullptr, from) {}
  Settings(Settings&& from) noexcept
    : Settings() {
    *this = ::std::move(from);
  }

  inline Settings& operator=(const Settings& from) {
    CopyFrom(from);
    return *this;
  }
  inline Settings& operator=(Settings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Settings& default_instance() {
    return *internal_default_instance();
  }
  static inline const Settings* internal_default_instance() {
    return reinterpret_cast<const Settings*>(
               &_Settings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Settings& a, Settings& b) {
    a.Swap(&b);
  }
  inline void Swap(Settings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Settings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Settings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Settings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Settings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Settings& from) {
    Settings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Settings* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.Settings";
  }
  protected:
  explicit Settings(::google::protobuf::Arena* arena);
  Settings(::google::protobuf::Arena* arena, const Settings& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationLengthFieldNumber = 1,
    kMaxSearchIterationsFieldNumber = 4,
    kMaxSmootherIterationsFieldNumber = 5,
    kSensorFlagFieldNumber = 2,
    kForceFlagFieldNumber = 3,
    kVerboseIterationFieldNumber = 7,
    kVerboseOptimizeFieldNumber = 8,
    kGradientToleranceFieldNumber = 6,
    kStepScalingFieldNumber = 11,
    kRegularizationInitialFieldNumber = 12,
    kRegularizationScalingFieldNumber = 13,
    kSearchTypeFieldNumber = 10,
    kVerboseCostFieldNumber = 9,
    kTimeScalingForceFieldNumber = 14,
    kTimeScalingSensorFieldNumber = 15,
    kAssembleSensorJacobianFieldNumber = 18,
    kSearchDirectionToleranceFieldNumber = 16,
    kCostToleranceFieldNumber = 17,
    kAssembleForceJacobianFieldNumber = 19,
    kAssembleSensorNormHessianFieldNumber = 20,
    kAssembleForceNormHessianFieldNumber = 21,
    kFirstStepPositionSensorsFieldNumber = 22,
    kLastStepPositionSensorsFieldNumber = 23,
    kLastStepVelocitySensorsFieldNumber = 24,
  };
  // optional int32 configuration_length = 1;
  bool has_configuration_length() const;
  void clear_configuration_length() ;
  ::int32_t configuration_length() const;
  void set_configuration_length(::int32_t value);

  private:
  ::int32_t _internal_configuration_length() const;
  void _internal_set_configuration_length(::int32_t value);

  public:
  // optional int32 max_search_iterations = 4;
  bool has_max_search_iterations() const;
  void clear_max_search_iterations() ;
  ::int32_t max_search_iterations() const;
  void set_max_search_iterations(::int32_t value);

  private:
  ::int32_t _internal_max_search_iterations() const;
  void _internal_set_max_search_iterations(::int32_t value);

  public:
  // optional int32 max_smoother_iterations = 5;
  bool has_max_smoother_iterations() const;
  void clear_max_smoother_iterations() ;
  ::int32_t max_smoother_iterations() const;
  void set_max_smoother_iterations(::int32_t value);

  private:
  ::int32_t _internal_max_smoother_iterations() const;
  void _internal_set_max_smoother_iterations(::int32_t value);

  public:
  // optional bool sensor_flag = 2;
  bool has_sensor_flag() const;
  void clear_sensor_flag() ;
  bool sensor_flag() const;
  void set_sensor_flag(bool value);

  private:
  bool _internal_sensor_flag() const;
  void _internal_set_sensor_flag(bool value);

  public:
  // optional bool force_flag = 3;
  bool has_force_flag() const;
  void clear_force_flag() ;
  bool force_flag() const;
  void set_force_flag(bool value);

  private:
  bool _internal_force_flag() const;
  void _internal_set_force_flag(bool value);

  public:
  // optional bool verbose_iteration = 7;
  bool has_verbose_iteration() const;
  void clear_verbose_iteration() ;
  bool verbose_iteration() const;
  void set_verbose_iteration(bool value);

  private:
  bool _internal_verbose_iteration() const;
  void _internal_set_verbose_iteration(bool value);

  public:
  // optional bool verbose_optimize = 8;
  bool has_verbose_optimize() const;
  void clear_verbose_optimize() ;
  bool verbose_optimize() const;
  void set_verbose_optimize(bool value);

  private:
  bool _internal_verbose_optimize() const;
  void _internal_set_verbose_optimize(bool value);

  public:
  // optional double gradient_tolerance = 6;
  bool has_gradient_tolerance() const;
  void clear_gradient_tolerance() ;
  double gradient_tolerance() const;
  void set_gradient_tolerance(double value);

  private:
  double _internal_gradient_tolerance() const;
  void _internal_set_gradient_tolerance(double value);

  public:
  // optional double step_scaling = 11;
  bool has_step_scaling() const;
  void clear_step_scaling() ;
  double step_scaling() const;
  void set_step_scaling(double value);

  private:
  double _internal_step_scaling() const;
  void _internal_set_step_scaling(double value);

  public:
  // optional double regularization_initial = 12;
  bool has_regularization_initial() const;
  void clear_regularization_initial() ;
  double regularization_initial() const;
  void set_regularization_initial(double value);

  private:
  double _internal_regularization_initial() const;
  void _internal_set_regularization_initial(double value);

  public:
  // optional double regularization_scaling = 13;
  bool has_regularization_scaling() const;
  void clear_regularization_scaling() ;
  double regularization_scaling() const;
  void set_regularization_scaling(double value);

  private:
  double _internal_regularization_scaling() const;
  void _internal_set_regularization_scaling(double value);

  public:
  // optional int32 search_type = 10;
  bool has_search_type() const;
  void clear_search_type() ;
  ::int32_t search_type() const;
  void set_search_type(::int32_t value);

  private:
  ::int32_t _internal_search_type() const;
  void _internal_set_search_type(::int32_t value);

  public:
  // optional bool verbose_cost = 9;
  bool has_verbose_cost() const;
  void clear_verbose_cost() ;
  bool verbose_cost() const;
  void set_verbose_cost(bool value);

  private:
  bool _internal_verbose_cost() const;
  void _internal_set_verbose_cost(bool value);

  public:
  // optional bool time_scaling_force = 14;
  bool has_time_scaling_force() const;
  void clear_time_scaling_force() ;
  bool time_scaling_force() const;
  void set_time_scaling_force(bool value);

  private:
  bool _internal_time_scaling_force() const;
  void _internal_set_time_scaling_force(bool value);

  public:
  // optional bool time_scaling_sensor = 15;
  bool has_time_scaling_sensor() const;
  void clear_time_scaling_sensor() ;
  bool time_scaling_sensor() const;
  void set_time_scaling_sensor(bool value);

  private:
  bool _internal_time_scaling_sensor() const;
  void _internal_set_time_scaling_sensor(bool value);

  public:
  // optional bool assemble_sensor_jacobian = 18;
  bool has_assemble_sensor_jacobian() const;
  void clear_assemble_sensor_jacobian() ;
  bool assemble_sensor_jacobian() const;
  void set_assemble_sensor_jacobian(bool value);

  private:
  bool _internal_assemble_sensor_jacobian() const;
  void _internal_set_assemble_sensor_jacobian(bool value);

  public:
  // optional double search_direction_tolerance = 16;
  bool has_search_direction_tolerance() const;
  void clear_search_direction_tolerance() ;
  double search_direction_tolerance() const;
  void set_search_direction_tolerance(double value);

  private:
  double _internal_search_direction_tolerance() const;
  void _internal_set_search_direction_tolerance(double value);

  public:
  // optional double cost_tolerance = 17;
  bool has_cost_tolerance() const;
  void clear_cost_tolerance() ;
  double cost_tolerance() const;
  void set_cost_tolerance(double value);

  private:
  double _internal_cost_tolerance() const;
  void _internal_set_cost_tolerance(double value);

  public:
  // optional bool assemble_force_jacobian = 19;
  bool has_assemble_force_jacobian() const;
  void clear_assemble_force_jacobian() ;
  bool assemble_force_jacobian() const;
  void set_assemble_force_jacobian(bool value);

  private:
  bool _internal_assemble_force_jacobian() const;
  void _internal_set_assemble_force_jacobian(bool value);

  public:
  // optional bool assemble_sensor_norm_hessian = 20;
  bool has_assemble_sensor_norm_hessian() const;
  void clear_assemble_sensor_norm_hessian() ;
  bool assemble_sensor_norm_hessian() const;
  void set_assemble_sensor_norm_hessian(bool value);

  private:
  bool _internal_assemble_sensor_norm_hessian() const;
  void _internal_set_assemble_sensor_norm_hessian(bool value);

  public:
  // optional bool assemble_force_norm_hessian = 21;
  bool has_assemble_force_norm_hessian() const;
  void clear_assemble_force_norm_hessian() ;
  bool assemble_force_norm_hessian() const;
  void set_assemble_force_norm_hessian(bool value);

  private:
  bool _internal_assemble_force_norm_hessian() const;
  void _internal_set_assemble_force_norm_hessian(bool value);

  public:
  // optional bool first_step_position_sensors = 22;
  bool has_first_step_position_sensors() const;
  void clear_first_step_position_sensors() ;
  bool first_step_position_sensors() const;
  void set_first_step_position_sensors(bool value);

  private:
  bool _internal_first_step_position_sensors() const;
  void _internal_set_first_step_position_sensors(bool value);

  public:
  // optional bool last_step_position_sensors = 23;
  bool has_last_step_position_sensors() const;
  void clear_last_step_position_sensors() ;
  bool last_step_position_sensors() const;
  void set_last_step_position_sensors(bool value);

  private:
  bool _internal_last_step_position_sensors() const;
  void _internal_set_last_step_position_sensors(bool value);

  public:
  // optional bool last_step_velocity_sensors = 24;
  bool has_last_step_velocity_sensors() const;
  void clear_last_step_velocity_sensors() ;
  bool last_step_velocity_sensors() const;
  void set_last_step_velocity_sensors(bool value);

  private:
  bool _internal_last_step_velocity_sensors() const;
  void _internal_set_last_step_velocity_sensors(bool value);

  public:
  // @@protoc_insertion_point(class_scope:direct.Settings)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 24, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t configuration_length_;
    ::int32_t max_search_iterations_;
    ::int32_t max_smoother_iterations_;
    bool sensor_flag_;
    bool force_flag_;
    bool verbose_iteration_;
    bool verbose_optimize_;
    double gradient_tolerance_;
    double step_scaling_;
    double regularization_initial_;
    double regularization_scaling_;
    ::int32_t search_type_;
    bool verbose_cost_;
    bool time_scaling_force_;
    bool time_scaling_sensor_;
    bool assemble_sensor_jacobian_;
    double search_direction_tolerance_;
    double cost_tolerance_;
    bool assemble_force_jacobian_;
    bool assemble_sensor_norm_hessian_;
    bool assemble_force_norm_hessian_;
    bool first_step_position_sensors_;
    bool last_step_position_sensors_;
    bool last_step_velocity_sensors_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class SensorInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.SensorInfoResponse) */ {
 public:
  inline SensorInfoResponse() : SensorInfoResponse(nullptr) {}
  ~SensorInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline SensorInfoResponse(const SensorInfoResponse& from)
      : SensorInfoResponse(nullptr, from) {}
  SensorInfoResponse(SensorInfoResponse&& from) noexcept
    : SensorInfoResponse() {
    *this = ::std::move(from);
  }

  inline SensorInfoResponse& operator=(const SensorInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorInfoResponse& operator=(SensorInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorInfoResponse* internal_default_instance() {
    return reinterpret_cast<const SensorInfoResponse*>(
               &_SensorInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SensorInfoResponse& a, SensorInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorInfoResponse& from) {
    SensorInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.SensorInfoResponse";
  }
  protected:
  explicit SensorInfoResponse(::google::protobuf::Arena* arena);
  SensorInfoResponse(::google::protobuf::Arena* arena, const SensorInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartIndexFieldNumber = 1,
    kNumMeasurementsFieldNumber = 2,
    kDimMeasurementsFieldNumber = 3,
  };
  // int32 start_index = 1;
  void clear_start_index() ;
  ::int32_t start_index() const;
  void set_start_index(::int32_t value);

  private:
  ::int32_t _internal_start_index() const;
  void _internal_set_start_index(::int32_t value);

  public:
  // int32 num_measurements = 2;
  void clear_num_measurements() ;
  ::int32_t num_measurements() const;
  void set_num_measurements(::int32_t value);

  private:
  ::int32_t _internal_num_measurements() const;
  void _internal_set_num_measurements(::int32_t value);

  public:
  // int32 dim_measurements = 3;
  void clear_dim_measurements() ;
  ::int32_t dim_measurements() const;
  void set_dim_measurements(::int32_t value);

  private:
  ::int32_t _internal_dim_measurements() const;
  void _internal_set_dim_measurements(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:direct.SensorInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t start_index_;
    ::int32_t num_measurements_;
    ::int32_t dim_measurements_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class SensorInfoRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:direct.SensorInfoRequest) */ {
 public:
  inline SensorInfoRequest() : SensorInfoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline SensorInfoRequest(const SensorInfoRequest& from)
      : SensorInfoRequest(nullptr, from) {}
  SensorInfoRequest(SensorInfoRequest&& from) noexcept
    : SensorInfoRequest() {
    *this = ::std::move(from);
  }

  inline SensorInfoRequest& operator=(const SensorInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorInfoRequest& operator=(SensorInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorInfoRequest* internal_default_instance() {
    return reinterpret_cast<const SensorInfoRequest*>(
               &_SensorInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SensorInfoRequest& a, SensorInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorInfoRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SensorInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SensorInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.SensorInfoRequest";
  }
  protected:
  explicit SensorInfoRequest(::google::protobuf::Arena* arena);
  SensorInfoRequest(::google::protobuf::Arena* arena, const SensorInfoRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:direct.SensorInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class ResetResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:direct.ResetResponse) */ {
 public:
  inline ResetResponse() : ResetResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResetResponse(::google::protobuf::internal::ConstantInitialized);

  inline ResetResponse(const ResetResponse& from)
      : ResetResponse(nullptr, from) {}
  ResetResponse(ResetResponse&& from) noexcept
    : ResetResponse() {
    *this = ::std::move(from);
  }

  inline ResetResponse& operator=(const ResetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetResponse& operator=(ResetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetResponse* internal_default_instance() {
    return reinterpret_cast<const ResetResponse*>(
               &_ResetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResetResponse& a, ResetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.ResetResponse";
  }
  protected:
  explicit ResetResponse(::google::protobuf::Arena* arena);
  ResetResponse(::google::protobuf::Arena* arena, const ResetResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:direct.ResetResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class ResetRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:direct.ResetRequest) */ {
 public:
  inline ResetRequest() : ResetRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResetRequest(::google::protobuf::internal::ConstantInitialized);

  inline ResetRequest(const ResetRequest& from)
      : ResetRequest(nullptr, from) {}
  ResetRequest(ResetRequest&& from) noexcept
    : ResetRequest() {
    *this = ::std::move(from);
  }

  inline ResetRequest& operator=(const ResetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetRequest& operator=(ResetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetRequest* internal_default_instance() {
    return reinterpret_cast<const ResetRequest*>(
               &_ResetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ResetRequest& a, ResetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.ResetRequest";
  }
  protected:
  explicit ResetRequest(::google::protobuf::Arena* arena);
  ResetRequest(::google::protobuf::Arena* arena, const ResetRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:direct.ResetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class OptimizeResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:direct.OptimizeResponse) */ {
 public:
  inline OptimizeResponse() : OptimizeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OptimizeResponse(::google::protobuf::internal::ConstantInitialized);

  inline OptimizeResponse(const OptimizeResponse& from)
      : OptimizeResponse(nullptr, from) {}
  OptimizeResponse(OptimizeResponse&& from) noexcept
    : OptimizeResponse() {
    *this = ::std::move(from);
  }

  inline OptimizeResponse& operator=(const OptimizeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimizeResponse& operator=(OptimizeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimizeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptimizeResponse* internal_default_instance() {
    return reinterpret_cast<const OptimizeResponse*>(
               &_OptimizeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(OptimizeResponse& a, OptimizeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OptimizeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimizeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimizeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptimizeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OptimizeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OptimizeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.OptimizeResponse";
  }
  protected:
  explicit OptimizeResponse(::google::protobuf::Arena* arena);
  OptimizeResponse(::google::protobuf::Arena* arena, const OptimizeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:direct.OptimizeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class OptimizeRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:direct.OptimizeRequest) */ {
 public:
  inline OptimizeRequest() : OptimizeRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OptimizeRequest(::google::protobuf::internal::ConstantInitialized);

  inline OptimizeRequest(const OptimizeRequest& from)
      : OptimizeRequest(nullptr, from) {}
  OptimizeRequest(OptimizeRequest&& from) noexcept
    : OptimizeRequest() {
    *this = ::std::move(from);
  }

  inline OptimizeRequest& operator=(const OptimizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptimizeRequest& operator=(OptimizeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptimizeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptimizeRequest* internal_default_instance() {
    return reinterpret_cast<const OptimizeRequest*>(
               &_OptimizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(OptimizeRequest& a, OptimizeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OptimizeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptimizeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptimizeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OptimizeRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const OptimizeRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const OptimizeRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.OptimizeRequest";
  }
  protected:
  explicit OptimizeRequest(::google::protobuf::Arena* arena);
  OptimizeRequest(::google::protobuf::Arena* arena, const OptimizeRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:direct.OptimizeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class Noise final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.Noise) */ {
 public:
  inline Noise() : Noise(nullptr) {}
  ~Noise() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Noise(::google::protobuf::internal::ConstantInitialized);

  inline Noise(const Noise& from)
      : Noise(nullptr, from) {}
  Noise(Noise&& from) noexcept
    : Noise() {
    *this = ::std::move(from);
  }

  inline Noise& operator=(const Noise& from) {
    CopyFrom(from);
    return *this;
  }
  inline Noise& operator=(Noise&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Noise& default_instance() {
    return *internal_default_instance();
  }
  static inline const Noise* internal_default_instance() {
    return reinterpret_cast<const Noise*>(
               &_Noise_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Noise& a, Noise& b) {
    a.Swap(&b);
  }
  inline void Swap(Noise* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Noise* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Noise* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Noise>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Noise& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Noise& from) {
    Noise::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Noise* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.Noise";
  }
  protected:
  explicit Noise(::google::protobuf::Arena* arena);
  Noise(::google::protobuf::Arena* arena, const Noise& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessFieldNumber = 1,
    kSensorFieldNumber = 2,
    kParameterFieldNumber = 3,
  };
  // repeated double process = 1 [packed = true];
  int process_size() const;
  private:
  int _internal_process_size() const;

  public:
  void clear_process() ;
  double process(int index) const;
  void set_process(int index, double value);
  void add_process(double value);
  const ::google::protobuf::RepeatedField<double>& process() const;
  ::google::protobuf::RepeatedField<double>* mutable_process();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_process() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_process();

  public:
  // repeated double sensor = 2 [packed = true];
  int sensor_size() const;
  private:
  int _internal_sensor_size() const;

  public:
  void clear_sensor() ;
  double sensor(int index) const;
  void set_sensor(int index, double value);
  void add_sensor(double value);
  const ::google::protobuf::RepeatedField<double>& sensor() const;
  ::google::protobuf::RepeatedField<double>* mutable_sensor();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_sensor() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_sensor();

  public:
  // repeated double parameter = 3 [packed = true];
  int parameter_size() const;
  private:
  int _internal_parameter_size() const;

  public:
  void clear_parameter() ;
  double parameter(int index) const;
  void set_parameter(int index, double value);
  void add_parameter(double value);
  const ::google::protobuf::RepeatedField<double>& parameter() const;
  ::google::protobuf::RepeatedField<double>* mutable_parameter();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_parameter() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_parameter();

  public:
  // @@protoc_insertion_point(class_scope:direct.Noise)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> process_;
    ::google::protobuf::RepeatedField<double> sensor_;
    ::google::protobuf::RepeatedField<double> parameter_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class MjModel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.MjModel) */ {
 public:
  inline MjModel() : MjModel(nullptr) {}
  ~MjModel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MjModel(::google::protobuf::internal::ConstantInitialized);

  inline MjModel(const MjModel& from)
      : MjModel(nullptr, from) {}
  MjModel(MjModel&& from) noexcept
    : MjModel() {
    *this = ::std::move(from);
  }

  inline MjModel& operator=(const MjModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline MjModel& operator=(MjModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MjModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const MjModel* internal_default_instance() {
    return reinterpret_cast<const MjModel*>(
               &_MjModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MjModel& a, MjModel& b) {
    a.Swap(&b);
  }
  inline void Swap(MjModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MjModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MjModel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MjModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MjModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MjModel& from) {
    MjModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MjModel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.MjModel";
  }
  protected:
  explicit MjModel(::google::protobuf::Arena* arena);
  MjModel(::google::protobuf::Arena* arena, const MjModel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMjbFieldNumber = 1,
    kXmlFieldNumber = 2,
  };
  // optional bytes mjb = 1;
  bool has_mjb() const;
  void clear_mjb() ;
  const std::string& mjb() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mjb(Arg_&& arg, Args_... args);
  std::string* mutable_mjb();
  PROTOBUF_NODISCARD std::string* release_mjb();
  void set_allocated_mjb(std::string* value);

  private:
  const std::string& _internal_mjb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mjb(
      const std::string& value);
  std::string* _internal_mutable_mjb();

  public:
  // optional string xml = 2;
  bool has_xml() const;
  void clear_xml() ;
  const std::string& xml() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_xml(Arg_&& arg, Args_... args);
  std::string* mutable_xml();
  PROTOBUF_NODISCARD std::string* release_xml();
  void set_allocated_xml(std::string* value);

  private:
  const std::string& _internal_xml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xml(
      const std::string& value);
  std::string* _internal_mutable_xml();

  public:
  // @@protoc_insertion_point(class_scope:direct.MjModel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      26, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr mjb_;
    ::google::protobuf::internal::ArenaStringPtr xml_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class InitResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:direct.InitResponse) */ {
 public:
  inline InitResponse() : InitResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InitResponse(::google::protobuf::internal::ConstantInitialized);

  inline InitResponse(const InitResponse& from)
      : InitResponse(nullptr, from) {}
  InitResponse(InitResponse&& from) noexcept
    : InitResponse() {
    *this = ::std::move(from);
  }

  inline InitResponse& operator=(const InitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitResponse& operator=(InitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitResponse* internal_default_instance() {
    return reinterpret_cast<const InitResponse*>(
               &_InitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InitResponse& a, InitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.InitResponse";
  }
  protected:
  explicit InitResponse(::google::protobuf::Arena* arena);
  InitResponse(::google::protobuf::Arena* arena, const InitResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:direct.InitResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class Data final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Data(::google::protobuf::internal::ConstantInitialized);

  inline Data(const Data& from)
      : Data(nullptr, from) {}
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Data& from) {
    Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Data* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.Data";
  }
  protected:
  explicit Data(::google::protobuf::Arena* arena);
  Data(::google::protobuf::Arena* arena, const Data& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 1,
    kVelocityFieldNumber = 2,
    kAccelerationFieldNumber = 3,
    kTimeFieldNumber = 4,
    kConfigurationPreviousFieldNumber = 5,
    kSensorMeasurementFieldNumber = 6,
    kSensorPredictionFieldNumber = 7,
    kSensorMaskFieldNumber = 8,
    kForceMeasurementFieldNumber = 9,
    kForcePredictionFieldNumber = 10,
    kParametersFieldNumber = 11,
    kParametersPreviousFieldNumber = 12,
  };
  // repeated double configuration = 1 [packed = true];
  int configuration_size() const;
  private:
  int _internal_configuration_size() const;

  public:
  void clear_configuration() ;
  double configuration(int index) const;
  void set_configuration(int index, double value);
  void add_configuration(double value);
  const ::google::protobuf::RepeatedField<double>& configuration() const;
  ::google::protobuf::RepeatedField<double>* mutable_configuration();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_configuration() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_configuration();

  public:
  // repeated double velocity = 2 [packed = true];
  int velocity_size() const;
  private:
  int _internal_velocity_size() const;

  public:
  void clear_velocity() ;
  double velocity(int index) const;
  void set_velocity(int index, double value);
  void add_velocity(double value);
  const ::google::protobuf::RepeatedField<double>& velocity() const;
  ::google::protobuf::RepeatedField<double>* mutable_velocity();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_velocity() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_velocity();

  public:
  // repeated double acceleration = 3 [packed = true];
  int acceleration_size() const;
  private:
  int _internal_acceleration_size() const;

  public:
  void clear_acceleration() ;
  double acceleration(int index) const;
  void set_acceleration(int index, double value);
  void add_acceleration(double value);
  const ::google::protobuf::RepeatedField<double>& acceleration() const;
  ::google::protobuf::RepeatedField<double>* mutable_acceleration();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_acceleration() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_acceleration();

  public:
  // repeated double time = 4 [packed = true];
  int time_size() const;
  private:
  int _internal_time_size() const;

  public:
  void clear_time() ;
  double time(int index) const;
  void set_time(int index, double value);
  void add_time(double value);
  const ::google::protobuf::RepeatedField<double>& time() const;
  ::google::protobuf::RepeatedField<double>* mutable_time();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_time() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_time();

  public:
  // repeated double configuration_previous = 5 [packed = true];
  int configuration_previous_size() const;
  private:
  int _internal_configuration_previous_size() const;

  public:
  void clear_configuration_previous() ;
  double configuration_previous(int index) const;
  void set_configuration_previous(int index, double value);
  void add_configuration_previous(double value);
  const ::google::protobuf::RepeatedField<double>& configuration_previous() const;
  ::google::protobuf::RepeatedField<double>* mutable_configuration_previous();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_configuration_previous() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_configuration_previous();

  public:
  // repeated double sensor_measurement = 6 [packed = true];
  int sensor_measurement_size() const;
  private:
  int _internal_sensor_measurement_size() const;

  public:
  void clear_sensor_measurement() ;
  double sensor_measurement(int index) const;
  void set_sensor_measurement(int index, double value);
  void add_sensor_measurement(double value);
  const ::google::protobuf::RepeatedField<double>& sensor_measurement() const;
  ::google::protobuf::RepeatedField<double>* mutable_sensor_measurement();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_sensor_measurement() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_sensor_measurement();

  public:
  // repeated double sensor_prediction = 7 [packed = true];
  int sensor_prediction_size() const;
  private:
  int _internal_sensor_prediction_size() const;

  public:
  void clear_sensor_prediction() ;
  double sensor_prediction(int index) const;
  void set_sensor_prediction(int index, double value);
  void add_sensor_prediction(double value);
  const ::google::protobuf::RepeatedField<double>& sensor_prediction() const;
  ::google::protobuf::RepeatedField<double>* mutable_sensor_prediction();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_sensor_prediction() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_sensor_prediction();

  public:
  // repeated int32 sensor_mask = 8 [packed = true];
  int sensor_mask_size() const;
  private:
  int _internal_sensor_mask_size() const;

  public:
  void clear_sensor_mask() ;
  ::int32_t sensor_mask(int index) const;
  void set_sensor_mask(int index, ::int32_t value);
  void add_sensor_mask(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& sensor_mask() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_sensor_mask();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_sensor_mask() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_sensor_mask();

  public:
  // repeated double force_measurement = 9 [packed = true];
  int force_measurement_size() const;
  private:
  int _internal_force_measurement_size() const;

  public:
  void clear_force_measurement() ;
  double force_measurement(int index) const;
  void set_force_measurement(int index, double value);
  void add_force_measurement(double value);
  const ::google::protobuf::RepeatedField<double>& force_measurement() const;
  ::google::protobuf::RepeatedField<double>* mutable_force_measurement();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_force_measurement() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_force_measurement();

  public:
  // repeated double force_prediction = 10 [packed = true];
  int force_prediction_size() const;
  private:
  int _internal_force_prediction_size() const;

  public:
  void clear_force_prediction() ;
  double force_prediction(int index) const;
  void set_force_prediction(int index, double value);
  void add_force_prediction(double value);
  const ::google::protobuf::RepeatedField<double>& force_prediction() const;
  ::google::protobuf::RepeatedField<double>* mutable_force_prediction();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_force_prediction() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_force_prediction();

  public:
  // repeated double parameters = 11 [packed = true];
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  double parameters(int index) const;
  void set_parameters(int index, double value);
  void add_parameters(double value);
  const ::google::protobuf::RepeatedField<double>& parameters() const;
  ::google::protobuf::RepeatedField<double>* mutable_parameters();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_parameters() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_parameters();

  public:
  // repeated double parameters_previous = 12 [packed = true];
  int parameters_previous_size() const;
  private:
  int _internal_parameters_previous_size() const;

  public:
  void clear_parameters_previous() ;
  double parameters_previous(int index) const;
  void set_parameters_previous(int index, double value);
  void add_parameters_previous(double value);
  const ::google::protobuf::RepeatedField<double>& parameters_previous() const;
  ::google::protobuf::RepeatedField<double>* mutable_parameters_previous();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_parameters_previous() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_parameters_previous();

  public:
  // @@protoc_insertion_point(class_scope:direct.Data)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> configuration_;
    ::google::protobuf::RepeatedField<double> velocity_;
    ::google::protobuf::RepeatedField<double> acceleration_;
    ::google::protobuf::RepeatedField<double> time_;
    ::google::protobuf::RepeatedField<double> configuration_previous_;
    ::google::protobuf::RepeatedField<double> sensor_measurement_;
    ::google::protobuf::RepeatedField<double> sensor_prediction_;
    ::google::protobuf::RepeatedField<::int32_t> sensor_mask_;
    mutable ::google::protobuf::internal::CachedSize _sensor_mask_cached_byte_size_;
    ::google::protobuf::RepeatedField<double> force_measurement_;
    ::google::protobuf::RepeatedField<double> force_prediction_;
    ::google::protobuf::RepeatedField<double> parameters_;
    ::google::protobuf::RepeatedField<double> parameters_previous_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class CostResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.CostResponse) */ {
 public:
  inline CostResponse() : CostResponse(nullptr) {}
  ~CostResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CostResponse(::google::protobuf::internal::ConstantInitialized);

  inline CostResponse(const CostResponse& from)
      : CostResponse(nullptr, from) {}
  CostResponse(CostResponse&& from) noexcept
    : CostResponse() {
    *this = ::std::move(from);
  }

  inline CostResponse& operator=(const CostResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CostResponse& operator=(CostResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CostResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CostResponse* internal_default_instance() {
    return reinterpret_cast<const CostResponse*>(
               &_CostResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CostResponse& a, CostResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CostResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CostResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CostResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CostResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CostResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CostResponse& from) {
    CostResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CostResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.CostResponse";
  }
  protected:
  explicit CostResponse(::google::protobuf::Arena* arena);
  CostResponse(::google::protobuf::Arena* arena, const CostResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGradientFieldNumber = 6,
    kHessianFieldNumber = 7,
    kResidualSensorFieldNumber = 8,
    kResidualForceFieldNumber = 9,
    kJacobianSensorFieldNumber = 10,
    kJacobianForceFieldNumber = 11,
    kNormGradientSensorFieldNumber = 12,
    kNormGradientForceFieldNumber = 13,
    kNormHessianSensorFieldNumber = 14,
    kNormHessianForceFieldNumber = 15,
    kTotalFieldNumber = 1,
    kSensorFieldNumber = 2,
    kForceFieldNumber = 3,
    kParameterFieldNumber = 4,
    kInitialFieldNumber = 5,
    kNvarFieldNumber = 16,
    kNsensorFieldNumber = 17,
    kNforceFieldNumber = 18,
  };
  // repeated double gradient = 6 [packed = true];
  int gradient_size() const;
  private:
  int _internal_gradient_size() const;

  public:
  void clear_gradient() ;
  double gradient(int index) const;
  void set_gradient(int index, double value);
  void add_gradient(double value);
  const ::google::protobuf::RepeatedField<double>& gradient() const;
  ::google::protobuf::RepeatedField<double>* mutable_gradient();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_gradient() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_gradient();

  public:
  // repeated double hessian = 7 [packed = true];
  int hessian_size() const;
  private:
  int _internal_hessian_size() const;

  public:
  void clear_hessian() ;
  double hessian(int index) const;
  void set_hessian(int index, double value);
  void add_hessian(double value);
  const ::google::protobuf::RepeatedField<double>& hessian() const;
  ::google::protobuf::RepeatedField<double>* mutable_hessian();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_hessian() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_hessian();

  public:
  // repeated double residual_sensor = 8 [packed = true];
  int residual_sensor_size() const;
  private:
  int _internal_residual_sensor_size() const;

  public:
  void clear_residual_sensor() ;
  double residual_sensor(int index) const;
  void set_residual_sensor(int index, double value);
  void add_residual_sensor(double value);
  const ::google::protobuf::RepeatedField<double>& residual_sensor() const;
  ::google::protobuf::RepeatedField<double>* mutable_residual_sensor();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_residual_sensor() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_residual_sensor();

  public:
  // repeated double residual_force = 9 [packed = true];
  int residual_force_size() const;
  private:
  int _internal_residual_force_size() const;

  public:
  void clear_residual_force() ;
  double residual_force(int index) const;
  void set_residual_force(int index, double value);
  void add_residual_force(double value);
  const ::google::protobuf::RepeatedField<double>& residual_force() const;
  ::google::protobuf::RepeatedField<double>* mutable_residual_force();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_residual_force() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_residual_force();

  public:
  // repeated double jacobian_sensor = 10 [packed = true];
  int jacobian_sensor_size() const;
  private:
  int _internal_jacobian_sensor_size() const;

  public:
  void clear_jacobian_sensor() ;
  double jacobian_sensor(int index) const;
  void set_jacobian_sensor(int index, double value);
  void add_jacobian_sensor(double value);
  const ::google::protobuf::RepeatedField<double>& jacobian_sensor() const;
  ::google::protobuf::RepeatedField<double>* mutable_jacobian_sensor();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_jacobian_sensor() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_jacobian_sensor();

  public:
  // repeated double jacobian_force = 11 [packed = true];
  int jacobian_force_size() const;
  private:
  int _internal_jacobian_force_size() const;

  public:
  void clear_jacobian_force() ;
  double jacobian_force(int index) const;
  void set_jacobian_force(int index, double value);
  void add_jacobian_force(double value);
  const ::google::protobuf::RepeatedField<double>& jacobian_force() const;
  ::google::protobuf::RepeatedField<double>* mutable_jacobian_force();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_jacobian_force() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_jacobian_force();

  public:
  // repeated double norm_gradient_sensor = 12 [packed = true];
  int norm_gradient_sensor_size() const;
  private:
  int _internal_norm_gradient_sensor_size() const;

  public:
  void clear_norm_gradient_sensor() ;
  double norm_gradient_sensor(int index) const;
  void set_norm_gradient_sensor(int index, double value);
  void add_norm_gradient_sensor(double value);
  const ::google::protobuf::RepeatedField<double>& norm_gradient_sensor() const;
  ::google::protobuf::RepeatedField<double>* mutable_norm_gradient_sensor();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_norm_gradient_sensor() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_norm_gradient_sensor();

  public:
  // repeated double norm_gradient_force = 13 [packed = true];
  int norm_gradient_force_size() const;
  private:
  int _internal_norm_gradient_force_size() const;

  public:
  void clear_norm_gradient_force() ;
  double norm_gradient_force(int index) const;
  void set_norm_gradient_force(int index, double value);
  void add_norm_gradient_force(double value);
  const ::google::protobuf::RepeatedField<double>& norm_gradient_force() const;
  ::google::protobuf::RepeatedField<double>* mutable_norm_gradient_force();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_norm_gradient_force() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_norm_gradient_force();

  public:
  // repeated double norm_hessian_sensor = 14 [packed = true];
  int norm_hessian_sensor_size() const;
  private:
  int _internal_norm_hessian_sensor_size() const;

  public:
  void clear_norm_hessian_sensor() ;
  double norm_hessian_sensor(int index) const;
  void set_norm_hessian_sensor(int index, double value);
  void add_norm_hessian_sensor(double value);
  const ::google::protobuf::RepeatedField<double>& norm_hessian_sensor() const;
  ::google::protobuf::RepeatedField<double>* mutable_norm_hessian_sensor();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_norm_hessian_sensor() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_norm_hessian_sensor();

  public:
  // repeated double norm_hessian_force = 15 [packed = true];
  int norm_hessian_force_size() const;
  private:
  int _internal_norm_hessian_force_size() const;

  public:
  void clear_norm_hessian_force() ;
  double norm_hessian_force(int index) const;
  void set_norm_hessian_force(int index, double value);
  void add_norm_hessian_force(double value);
  const ::google::protobuf::RepeatedField<double>& norm_hessian_force() const;
  ::google::protobuf::RepeatedField<double>* mutable_norm_hessian_force();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_norm_hessian_force() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_norm_hessian_force();

  public:
  // double total = 1;
  void clear_total() ;
  double total() const;
  void set_total(double value);

  private:
  double _internal_total() const;
  void _internal_set_total(double value);

  public:
  // double sensor = 2;
  void clear_sensor() ;
  double sensor() const;
  void set_sensor(double value);

  private:
  double _internal_sensor() const;
  void _internal_set_sensor(double value);

  public:
  // double force = 3;
  void clear_force() ;
  double force() const;
  void set_force(double value);

  private:
  double _internal_force() const;
  void _internal_set_force(double value);

  public:
  // double parameter = 4;
  void clear_parameter() ;
  double parameter() const;
  void set_parameter(double value);

  private:
  double _internal_parameter() const;
  void _internal_set_parameter(double value);

  public:
  // double initial = 5;
  void clear_initial() ;
  double initial() const;
  void set_initial(double value);

  private:
  double _internal_initial() const;
  void _internal_set_initial(double value);

  public:
  // int32 nvar = 16;
  void clear_nvar() ;
  ::int32_t nvar() const;
  void set_nvar(::int32_t value);

  private:
  ::int32_t _internal_nvar() const;
  void _internal_set_nvar(::int32_t value);

  public:
  // int32 nsensor = 17;
  void clear_nsensor() ;
  ::int32_t nsensor() const;
  void set_nsensor(::int32_t value);

  private:
  ::int32_t _internal_nsensor() const;
  void _internal_set_nsensor(::int32_t value);

  public:
  // int32 nforce = 18;
  void clear_nforce() ;
  ::int32_t nforce() const;
  void set_nforce(::int32_t value);

  private:
  ::int32_t _internal_nforce() const;
  void _internal_set_nforce(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:direct.CostResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 18, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> gradient_;
    ::google::protobuf::RepeatedField<double> hessian_;
    ::google::protobuf::RepeatedField<double> residual_sensor_;
    ::google::protobuf::RepeatedField<double> residual_force_;
    ::google::protobuf::RepeatedField<double> jacobian_sensor_;
    ::google::protobuf::RepeatedField<double> jacobian_force_;
    ::google::protobuf::RepeatedField<double> norm_gradient_sensor_;
    ::google::protobuf::RepeatedField<double> norm_gradient_force_;
    ::google::protobuf::RepeatedField<double> norm_hessian_sensor_;
    ::google::protobuf::RepeatedField<double> norm_hessian_force_;
    double total_;
    double sensor_;
    double force_;
    double parameter_;
    double initial_;
    ::int32_t nvar_;
    ::int32_t nsensor_;
    ::int32_t nforce_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class CostRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.CostRequest) */ {
 public:
  inline CostRequest() : CostRequest(nullptr) {}
  ~CostRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CostRequest(::google::protobuf::internal::ConstantInitialized);

  inline CostRequest(const CostRequest& from)
      : CostRequest(nullptr, from) {}
  CostRequest(CostRequest&& from) noexcept
    : CostRequest() {
    *this = ::std::move(from);
  }

  inline CostRequest& operator=(const CostRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CostRequest& operator=(CostRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CostRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CostRequest* internal_default_instance() {
    return reinterpret_cast<const CostRequest*>(
               &_CostRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CostRequest& a, CostRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CostRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CostRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CostRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CostRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CostRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CostRequest& from) {
    CostRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CostRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.CostRequest";
  }
  protected:
  explicit CostRequest(::google::protobuf::Arena* arena);
  CostRequest(::google::protobuf::Arena* arena, const CostRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDerivativesFieldNumber = 1,
    kInternalsFieldNumber = 2,
  };
  // optional bool derivatives = 1;
  bool has_derivatives() const;
  void clear_derivatives() ;
  bool derivatives() const;
  void set_derivatives(bool value);

  private:
  bool _internal_derivatives() const;
  void _internal_set_derivatives(bool value);

  public:
  // optional bool internals = 2;
  bool has_internals() const;
  void clear_internals() ;
  bool internals() const;
  void set_internals(bool value);

  private:
  bool _internal_internals() const;
  void _internal_set_internals(bool value);

  public:
  // @@protoc_insertion_point(class_scope:direct.CostRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool derivatives_;
    bool internals_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class StatusResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusResponse(::google::protobuf::internal::ConstantInitialized);

  inline StatusResponse(const StatusResponse& from)
      : StatusResponse(nullptr, from) {}
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.StatusResponse";
  }
  protected:
  explicit StatusResponse(::google::protobuf::Arena* arena);
  StatusResponse(::google::protobuf::Arena* arena, const StatusResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .direct.Status status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::direct::Status& status() const;
  PROTOBUF_NODISCARD ::direct::Status* release_status();
  ::direct::Status* mutable_status();
  void set_allocated_status(::direct::Status* value);
  void unsafe_arena_set_allocated_status(::direct::Status* value);
  ::direct::Status* unsafe_arena_release_status();

  private:
  const ::direct::Status& _internal_status() const;
  ::direct::Status* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:direct.StatusResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::direct::Status* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class SettingsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.SettingsResponse) */ {
 public:
  inline SettingsResponse() : SettingsResponse(nullptr) {}
  ~SettingsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SettingsResponse(::google::protobuf::internal::ConstantInitialized);

  inline SettingsResponse(const SettingsResponse& from)
      : SettingsResponse(nullptr, from) {}
  SettingsResponse(SettingsResponse&& from) noexcept
    : SettingsResponse() {
    *this = ::std::move(from);
  }

  inline SettingsResponse& operator=(const SettingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingsResponse& operator=(SettingsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingsResponse* internal_default_instance() {
    return reinterpret_cast<const SettingsResponse*>(
               &_SettingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SettingsResponse& a, SettingsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SettingsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SettingsResponse& from) {
    SettingsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SettingsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.SettingsResponse";
  }
  protected:
  explicit SettingsResponse(::google::protobuf::Arena* arena);
  SettingsResponse(::google::protobuf::Arena* arena, const SettingsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
  };
  // .direct.Settings settings = 1;
  bool has_settings() const;
  void clear_settings() ;
  const ::direct::Settings& settings() const;
  PROTOBUF_NODISCARD ::direct::Settings* release_settings();
  ::direct::Settings* mutable_settings();
  void set_allocated_settings(::direct::Settings* value);
  void unsafe_arena_set_allocated_settings(::direct::Settings* value);
  ::direct::Settings* unsafe_arena_release_settings();

  private:
  const ::direct::Settings& _internal_settings() const;
  ::direct::Settings* _internal_mutable_settings();

  public:
  // @@protoc_insertion_point(class_scope:direct.SettingsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::direct::Settings* settings_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class SettingsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.SettingsRequest) */ {
 public:
  inline SettingsRequest() : SettingsRequest(nullptr) {}
  ~SettingsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SettingsRequest(::google::protobuf::internal::ConstantInitialized);

  inline SettingsRequest(const SettingsRequest& from)
      : SettingsRequest(nullptr, from) {}
  SettingsRequest(SettingsRequest&& from) noexcept
    : SettingsRequest() {
    *this = ::std::move(from);
  }

  inline SettingsRequest& operator=(const SettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingsRequest& operator=(SettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingsRequest* internal_default_instance() {
    return reinterpret_cast<const SettingsRequest*>(
               &_SettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SettingsRequest& a, SettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SettingsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SettingsRequest& from) {
    SettingsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SettingsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.SettingsRequest";
  }
  protected:
  explicit SettingsRequest(::google::protobuf::Arena* arena);
  SettingsRequest(::google::protobuf::Arena* arena, const SettingsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
  };
  // optional .direct.Settings settings = 1;
  bool has_settings() const;
  void clear_settings() ;
  const ::direct::Settings& settings() const;
  PROTOBUF_NODISCARD ::direct::Settings* release_settings();
  ::direct::Settings* mutable_settings();
  void set_allocated_settings(::direct::Settings* value);
  void unsafe_arena_set_allocated_settings(::direct::Settings* value);
  ::direct::Settings* unsafe_arena_release_settings();

  private:
  const ::direct::Settings& _internal_settings() const;
  ::direct::Settings* _internal_mutable_settings();

  public:
  // @@protoc_insertion_point(class_scope:direct.SettingsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::direct::Settings* settings_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class NoiseResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.NoiseResponse) */ {
 public:
  inline NoiseResponse() : NoiseResponse(nullptr) {}
  ~NoiseResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoiseResponse(::google::protobuf::internal::ConstantInitialized);

  inline NoiseResponse(const NoiseResponse& from)
      : NoiseResponse(nullptr, from) {}
  NoiseResponse(NoiseResponse&& from) noexcept
    : NoiseResponse() {
    *this = ::std::move(from);
  }

  inline NoiseResponse& operator=(const NoiseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoiseResponse& operator=(NoiseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoiseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoiseResponse* internal_default_instance() {
    return reinterpret_cast<const NoiseResponse*>(
               &_NoiseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NoiseResponse& a, NoiseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NoiseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoiseResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoiseResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoiseResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoiseResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoiseResponse& from) {
    NoiseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoiseResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.NoiseResponse";
  }
  protected:
  explicit NoiseResponse(::google::protobuf::Arena* arena);
  NoiseResponse(::google::protobuf::Arena* arena, const NoiseResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoiseFieldNumber = 1,
  };
  // .direct.Noise noise = 1;
  bool has_noise() const;
  void clear_noise() ;
  const ::direct::Noise& noise() const;
  PROTOBUF_NODISCARD ::direct::Noise* release_noise();
  ::direct::Noise* mutable_noise();
  void set_allocated_noise(::direct::Noise* value);
  void unsafe_arena_set_allocated_noise(::direct::Noise* value);
  ::direct::Noise* unsafe_arena_release_noise();

  private:
  const ::direct::Noise& _internal_noise() const;
  ::direct::Noise* _internal_mutable_noise();

  public:
  // @@protoc_insertion_point(class_scope:direct.NoiseResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::direct::Noise* noise_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class NoiseRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.NoiseRequest) */ {
 public:
  inline NoiseRequest() : NoiseRequest(nullptr) {}
  ~NoiseRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoiseRequest(::google::protobuf::internal::ConstantInitialized);

  inline NoiseRequest(const NoiseRequest& from)
      : NoiseRequest(nullptr, from) {}
  NoiseRequest(NoiseRequest&& from) noexcept
    : NoiseRequest() {
    *this = ::std::move(from);
  }

  inline NoiseRequest& operator=(const NoiseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoiseRequest& operator=(NoiseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoiseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoiseRequest* internal_default_instance() {
    return reinterpret_cast<const NoiseRequest*>(
               &_NoiseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NoiseRequest& a, NoiseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NoiseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoiseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoiseRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoiseRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoiseRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoiseRequest& from) {
    NoiseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoiseRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.NoiseRequest";
  }
  protected:
  explicit NoiseRequest(::google::protobuf::Arena* arena);
  NoiseRequest(::google::protobuf::Arena* arena, const NoiseRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoiseFieldNumber = 1,
  };
  // optional .direct.Noise noise = 1;
  bool has_noise() const;
  void clear_noise() ;
  const ::direct::Noise& noise() const;
  PROTOBUF_NODISCARD ::direct::Noise* release_noise();
  ::direct::Noise* mutable_noise();
  void set_allocated_noise(::direct::Noise* value);
  void unsafe_arena_set_allocated_noise(::direct::Noise* value);
  ::direct::Noise* unsafe_arena_release_noise();

  private:
  const ::direct::Noise& _internal_noise() const;
  ::direct::Noise* _internal_mutable_noise();

  public:
  // @@protoc_insertion_point(class_scope:direct.NoiseRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::direct::Noise* noise_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class InitRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.InitRequest) */ {
 public:
  inline InitRequest() : InitRequest(nullptr) {}
  ~InitRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InitRequest(::google::protobuf::internal::ConstantInitialized);

  inline InitRequest(const InitRequest& from)
      : InitRequest(nullptr, from) {}
  InitRequest(InitRequest&& from) noexcept
    : InitRequest() {
    *this = ::std::move(from);
  }

  inline InitRequest& operator=(const InitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitRequest& operator=(InitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitRequest* internal_default_instance() {
    return reinterpret_cast<const InitRequest*>(
               &_InitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InitRequest& a, InitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InitRequest& from) {
    InitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InitRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.InitRequest";
  }
  protected:
  explicit InitRequest(::google::protobuf::Arena* arena);
  InitRequest(::google::protobuf::Arena* arena, const InitRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
    kConfigurationLengthFieldNumber = 2,
    kBufferLengthFieldNumber = 3,
  };
  // optional .direct.MjModel model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::direct::MjModel& model() const;
  PROTOBUF_NODISCARD ::direct::MjModel* release_model();
  ::direct::MjModel* mutable_model();
  void set_allocated_model(::direct::MjModel* value);
  void unsafe_arena_set_allocated_model(::direct::MjModel* value);
  ::direct::MjModel* unsafe_arena_release_model();

  private:
  const ::direct::MjModel& _internal_model() const;
  ::direct::MjModel* _internal_mutable_model();

  public:
  // optional int32 configuration_length = 2;
  bool has_configuration_length() const;
  void clear_configuration_length() ;
  ::int32_t configuration_length() const;
  void set_configuration_length(::int32_t value);

  private:
  ::int32_t _internal_configuration_length() const;
  void _internal_set_configuration_length(::int32_t value);

  public:
  // optional int32 buffer_length = 3;
  bool has_buffer_length() const;
  void clear_buffer_length() ;
  ::int32_t buffer_length() const;
  void set_buffer_length(::int32_t value);

  private:
  ::int32_t _internal_buffer_length() const;
  void _internal_set_buffer_length(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:direct.InitRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::direct::MjModel* model_;
    ::int32_t configuration_length_;
    ::int32_t buffer_length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class DataResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.DataResponse) */ {
 public:
  inline DataResponse() : DataResponse(nullptr) {}
  ~DataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataResponse(::google::protobuf::internal::ConstantInitialized);

  inline DataResponse(const DataResponse& from)
      : DataResponse(nullptr, from) {}
  DataResponse(DataResponse&& from) noexcept
    : DataResponse() {
    *this = ::std::move(from);
  }

  inline DataResponse& operator=(const DataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataResponse& operator=(DataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataResponse* internal_default_instance() {
    return reinterpret_cast<const DataResponse*>(
               &_DataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DataResponse& a, DataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataResponse& from) {
    DataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.DataResponse";
  }
  protected:
  explicit DataResponse(::google::protobuf::Arena* arena);
  DataResponse(::google::protobuf::Arena* arena, const DataResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .direct.Data data = 1;
  bool has_data() const;
  void clear_data() ;
  const ::direct::Data& data() const;
  PROTOBUF_NODISCARD ::direct::Data* release_data();
  ::direct::Data* mutable_data();
  void set_allocated_data(::direct::Data* value);
  void unsafe_arena_set_allocated_data(::direct::Data* value);
  ::direct::Data* unsafe_arena_release_data();

  private:
  const ::direct::Data& _internal_data() const;
  ::direct::Data* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:direct.DataResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::direct::Data* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};// -------------------------------------------------------------------

class DataRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:direct.DataRequest) */ {
 public:
  inline DataRequest() : DataRequest(nullptr) {}
  ~DataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DataRequest(::google::protobuf::internal::ConstantInitialized);

  inline DataRequest(const DataRequest& from)
      : DataRequest(nullptr, from) {}
  DataRequest(DataRequest&& from) noexcept
    : DataRequest() {
    *this = ::std::move(from);
  }

  inline DataRequest& operator=(const DataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataRequest& operator=(DataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataRequest* internal_default_instance() {
    return reinterpret_cast<const DataRequest*>(
               &_DataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DataRequest& a, DataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DataRequest& from) {
    DataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DataRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "direct.DataRequest";
  }
  protected:
  explicit DataRequest(::google::protobuf::Arena* arena);
  DataRequest(::google::protobuf::Arena* arena, const DataRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kIndexFieldNumber = 1,
  };
  // .direct.Data data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::direct::Data& data() const;
  PROTOBUF_NODISCARD ::direct::Data* release_data();
  ::direct::Data* mutable_data();
  void set_allocated_data(::direct::Data* value);
  void unsafe_arena_set_allocated_data(::direct::Data* value);
  ::direct::Data* unsafe_arena_release_data();

  private:
  const ::direct::Data& _internal_data() const;
  ::direct::Data* _internal_mutable_data();

  public:
  // int32 index = 1;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:direct.DataRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::direct::Data* data_;
    ::int32_t index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_direct_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MjModel

// optional bytes mjb = 1;
inline bool MjModel::has_mjb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MjModel::clear_mjb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mjb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MjModel::mjb() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.MjModel.mjb)
  return _internal_mjb();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MjModel::set_mjb(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mjb_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:direct.MjModel.mjb)
}
inline std::string* MjModel::mutable_mjb() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mjb();
  // @@protoc_insertion_point(field_mutable:direct.MjModel.mjb)
  return _s;
}
inline const std::string& MjModel::_internal_mjb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mjb_.Get();
}
inline void MjModel::_internal_set_mjb(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mjb_.Set(value, GetArena());
}
inline std::string* MjModel::_internal_mutable_mjb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mjb_.Mutable( GetArena());
}
inline std::string* MjModel::release_mjb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.MjModel.mjb)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.mjb_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mjb_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MjModel::set_allocated_mjb(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mjb_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mjb_.IsDefault()) {
          _impl_.mjb_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:direct.MjModel.mjb)
}

// optional string xml = 2;
inline bool MjModel::has_xml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MjModel::clear_xml() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.xml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MjModel::xml() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.MjModel.xml)
  return _internal_xml();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MjModel::set_xml(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.xml_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:direct.MjModel.xml)
}
inline std::string* MjModel::mutable_xml() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_xml();
  // @@protoc_insertion_point(field_mutable:direct.MjModel.xml)
  return _s;
}
inline const std::string& MjModel::_internal_xml() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.xml_.Get();
}
inline void MjModel::_internal_set_xml(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.xml_.Set(value, GetArena());
}
inline std::string* MjModel::_internal_mutable_xml() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.xml_.Mutable( GetArena());
}
inline std::string* MjModel::release_xml() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.MjModel.xml)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.xml_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.xml_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MjModel::set_allocated_xml(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.xml_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.xml_.IsDefault()) {
          _impl_.xml_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:direct.MjModel.xml)
}

// -------------------------------------------------------------------

// InitRequest

// optional .direct.MjModel model = 1;
inline bool InitRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void InitRequest::clear_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::direct::MjModel& InitRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::direct::MjModel* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::direct::MjModel&>(::direct::_MjModel_default_instance_);
}
inline const ::direct::MjModel& InitRequest::model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.InitRequest.model)
  return _internal_model();
}
inline void InitRequest::unsafe_arena_set_allocated_model(::direct::MjModel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::direct::MjModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:direct.InitRequest.model)
}
inline ::direct::MjModel* InitRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::MjModel* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::direct::MjModel* InitRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.InitRequest.model)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::MjModel* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::direct::MjModel* InitRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::direct::MjModel>(GetArena());
    _impl_.model_ = reinterpret_cast<::direct::MjModel*>(p);
  }
  return _impl_.model_;
}
inline ::direct::MjModel* InitRequest::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::direct::MjModel* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:direct.InitRequest.model)
  return _msg;
}
inline void InitRequest::set_allocated_model(::direct::MjModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::direct::MjModel*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::direct::MjModel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.model_ = reinterpret_cast<::direct::MjModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:direct.InitRequest.model)
}

// optional int32 configuration_length = 2;
inline bool InitRequest::has_configuration_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InitRequest::clear_configuration_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.configuration_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t InitRequest::configuration_length() const {
  // @@protoc_insertion_point(field_get:direct.InitRequest.configuration_length)
  return _internal_configuration_length();
}
inline void InitRequest::set_configuration_length(::int32_t value) {
  _internal_set_configuration_length(value);
  // @@protoc_insertion_point(field_set:direct.InitRequest.configuration_length)
}
inline ::int32_t InitRequest::_internal_configuration_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.configuration_length_;
}
inline void InitRequest::_internal_set_configuration_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.configuration_length_ = value;
}

// optional int32 buffer_length = 3;
inline bool InitRequest::has_buffer_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InitRequest::clear_buffer_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buffer_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t InitRequest::buffer_length() const {
  // @@protoc_insertion_point(field_get:direct.InitRequest.buffer_length)
  return _internal_buffer_length();
}
inline void InitRequest::set_buffer_length(::int32_t value) {
  _internal_set_buffer_length(value);
  // @@protoc_insertion_point(field_set:direct.InitRequest.buffer_length)
}
inline ::int32_t InitRequest::_internal_buffer_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buffer_length_;
}
inline void InitRequest::_internal_set_buffer_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.buffer_length_ = value;
}

// -------------------------------------------------------------------

// InitResponse

// -------------------------------------------------------------------

// Data

// repeated double configuration = 1 [packed = true];
inline int Data::_internal_configuration_size() const {
  return _internal_configuration().size();
}
inline int Data::configuration_size() const {
  return _internal_configuration_size();
}
inline void Data::clear_configuration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.configuration_.Clear();
}
inline double Data::configuration(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.configuration)
  return _internal_configuration().Get(index);
}
inline void Data::set_configuration(int index, double value) {
  _internal_mutable_configuration()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.configuration)
}
inline void Data::add_configuration(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_configuration()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.configuration)
}
inline const ::google::protobuf::RepeatedField<double>& Data::configuration() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.configuration)
  return _internal_configuration();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_configuration()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.configuration)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_configuration();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_configuration()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.configuration_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_configuration() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.configuration_;
}

// repeated double velocity = 2 [packed = true];
inline int Data::_internal_velocity_size() const {
  return _internal_velocity().size();
}
inline int Data::velocity_size() const {
  return _internal_velocity_size();
}
inline void Data::clear_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.velocity_.Clear();
}
inline double Data::velocity(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.velocity)
  return _internal_velocity().Get(index);
}
inline void Data::set_velocity(int index, double value) {
  _internal_mutable_velocity()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.velocity)
}
inline void Data::add_velocity(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_velocity()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.velocity)
}
inline const ::google::protobuf::RepeatedField<double>& Data::velocity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.velocity)
  return _internal_velocity();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_velocity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.velocity)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_velocity();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_velocity()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.velocity_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_velocity() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.velocity_;
}

// repeated double acceleration = 3 [packed = true];
inline int Data::_internal_acceleration_size() const {
  return _internal_acceleration().size();
}
inline int Data::acceleration_size() const {
  return _internal_acceleration_size();
}
inline void Data::clear_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acceleration_.Clear();
}
inline double Data::acceleration(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.acceleration)
  return _internal_acceleration().Get(index);
}
inline void Data::set_acceleration(int index, double value) {
  _internal_mutable_acceleration()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.acceleration)
}
inline void Data::add_acceleration(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_acceleration()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.acceleration)
}
inline const ::google::protobuf::RepeatedField<double>& Data::acceleration() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.acceleration)
  return _internal_acceleration();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_acceleration()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.acceleration)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_acceleration();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_acceleration()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acceleration_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_acceleration() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.acceleration_;
}

// repeated double time = 4 [packed = true];
inline int Data::_internal_time_size() const {
  return _internal_time().size();
}
inline int Data::time_size() const {
  return _internal_time_size();
}
inline void Data::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_.Clear();
}
inline double Data::time(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.time)
  return _internal_time().Get(index);
}
inline void Data::set_time(int index, double value) {
  _internal_mutable_time()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.time)
}
inline void Data::add_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_time()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.time)
}
inline const ::google::protobuf::RepeatedField<double>& Data::time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.time)
  return _internal_time();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_time()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.time)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_time();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_time()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_time() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.time_;
}

// repeated double configuration_previous = 5 [packed = true];
inline int Data::_internal_configuration_previous_size() const {
  return _internal_configuration_previous().size();
}
inline int Data::configuration_previous_size() const {
  return _internal_configuration_previous_size();
}
inline void Data::clear_configuration_previous() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.configuration_previous_.Clear();
}
inline double Data::configuration_previous(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.configuration_previous)
  return _internal_configuration_previous().Get(index);
}
inline void Data::set_configuration_previous(int index, double value) {
  _internal_mutable_configuration_previous()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.configuration_previous)
}
inline void Data::add_configuration_previous(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_configuration_previous()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.configuration_previous)
}
inline const ::google::protobuf::RepeatedField<double>& Data::configuration_previous() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.configuration_previous)
  return _internal_configuration_previous();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_configuration_previous()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.configuration_previous)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_configuration_previous();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_configuration_previous()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.configuration_previous_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_configuration_previous() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.configuration_previous_;
}

// repeated double sensor_measurement = 6 [packed = true];
inline int Data::_internal_sensor_measurement_size() const {
  return _internal_sensor_measurement().size();
}
inline int Data::sensor_measurement_size() const {
  return _internal_sensor_measurement_size();
}
inline void Data::clear_sensor_measurement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_measurement_.Clear();
}
inline double Data::sensor_measurement(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.sensor_measurement)
  return _internal_sensor_measurement().Get(index);
}
inline void Data::set_sensor_measurement(int index, double value) {
  _internal_mutable_sensor_measurement()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.sensor_measurement)
}
inline void Data::add_sensor_measurement(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sensor_measurement()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.sensor_measurement)
}
inline const ::google::protobuf::RepeatedField<double>& Data::sensor_measurement() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.sensor_measurement)
  return _internal_sensor_measurement();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_sensor_measurement()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.sensor_measurement)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sensor_measurement();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_sensor_measurement()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_measurement_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_sensor_measurement() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sensor_measurement_;
}

// repeated double sensor_prediction = 7 [packed = true];
inline int Data::_internal_sensor_prediction_size() const {
  return _internal_sensor_prediction().size();
}
inline int Data::sensor_prediction_size() const {
  return _internal_sensor_prediction_size();
}
inline void Data::clear_sensor_prediction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_prediction_.Clear();
}
inline double Data::sensor_prediction(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.sensor_prediction)
  return _internal_sensor_prediction().Get(index);
}
inline void Data::set_sensor_prediction(int index, double value) {
  _internal_mutable_sensor_prediction()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.sensor_prediction)
}
inline void Data::add_sensor_prediction(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sensor_prediction()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.sensor_prediction)
}
inline const ::google::protobuf::RepeatedField<double>& Data::sensor_prediction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.sensor_prediction)
  return _internal_sensor_prediction();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_sensor_prediction()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.sensor_prediction)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sensor_prediction();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_sensor_prediction()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_prediction_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_sensor_prediction() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sensor_prediction_;
}

// repeated int32 sensor_mask = 8 [packed = true];
inline int Data::_internal_sensor_mask_size() const {
  return _internal_sensor_mask().size();
}
inline int Data::sensor_mask_size() const {
  return _internal_sensor_mask_size();
}
inline void Data::clear_sensor_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_mask_.Clear();
}
inline ::int32_t Data::sensor_mask(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.sensor_mask)
  return _internal_sensor_mask().Get(index);
}
inline void Data::set_sensor_mask(int index, ::int32_t value) {
  _internal_mutable_sensor_mask()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.sensor_mask)
}
inline void Data::add_sensor_mask(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sensor_mask()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.sensor_mask)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Data::sensor_mask() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.sensor_mask)
  return _internal_sensor_mask();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Data::mutable_sensor_mask()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.sensor_mask)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sensor_mask();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Data::_internal_sensor_mask()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_mask_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Data::_internal_mutable_sensor_mask() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sensor_mask_;
}

// repeated double force_measurement = 9 [packed = true];
inline int Data::_internal_force_measurement_size() const {
  return _internal_force_measurement().size();
}
inline int Data::force_measurement_size() const {
  return _internal_force_measurement_size();
}
inline void Data::clear_force_measurement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_measurement_.Clear();
}
inline double Data::force_measurement(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.force_measurement)
  return _internal_force_measurement().Get(index);
}
inline void Data::set_force_measurement(int index, double value) {
  _internal_mutable_force_measurement()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.force_measurement)
}
inline void Data::add_force_measurement(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_force_measurement()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.force_measurement)
}
inline const ::google::protobuf::RepeatedField<double>& Data::force_measurement() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.force_measurement)
  return _internal_force_measurement();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_force_measurement()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.force_measurement)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_force_measurement();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_force_measurement()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_measurement_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_force_measurement() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.force_measurement_;
}

// repeated double force_prediction = 10 [packed = true];
inline int Data::_internal_force_prediction_size() const {
  return _internal_force_prediction().size();
}
inline int Data::force_prediction_size() const {
  return _internal_force_prediction_size();
}
inline void Data::clear_force_prediction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_prediction_.Clear();
}
inline double Data::force_prediction(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.force_prediction)
  return _internal_force_prediction().Get(index);
}
inline void Data::set_force_prediction(int index, double value) {
  _internal_mutable_force_prediction()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.force_prediction)
}
inline void Data::add_force_prediction(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_force_prediction()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.force_prediction)
}
inline const ::google::protobuf::RepeatedField<double>& Data::force_prediction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.force_prediction)
  return _internal_force_prediction();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_force_prediction()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.force_prediction)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_force_prediction();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_force_prediction()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_prediction_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_force_prediction() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.force_prediction_;
}

// repeated double parameters = 11 [packed = true];
inline int Data::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int Data::parameters_size() const {
  return _internal_parameters_size();
}
inline void Data::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline double Data::parameters(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.parameters)
  return _internal_parameters().Get(index);
}
inline void Data::set_parameters(int index, double value) {
  _internal_mutable_parameters()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.parameters)
}
inline void Data::add_parameters(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_parameters()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.parameters)
}
inline const ::google::protobuf::RepeatedField<double>& Data::parameters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_parameters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.parameters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_parameters();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_parameters()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_parameters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.parameters_;
}

// repeated double parameters_previous = 12 [packed = true];
inline int Data::_internal_parameters_previous_size() const {
  return _internal_parameters_previous().size();
}
inline int Data::parameters_previous_size() const {
  return _internal_parameters_previous_size();
}
inline void Data::clear_parameters_previous() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_previous_.Clear();
}
inline double Data::parameters_previous(int index) const {
  // @@protoc_insertion_point(field_get:direct.Data.parameters_previous)
  return _internal_parameters_previous().Get(index);
}
inline void Data::set_parameters_previous(int index, double value) {
  _internal_mutable_parameters_previous()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Data.parameters_previous)
}
inline void Data::add_parameters_previous(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_parameters_previous()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Data.parameters_previous)
}
inline const ::google::protobuf::RepeatedField<double>& Data::parameters_previous() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Data.parameters_previous)
  return _internal_parameters_previous();
}
inline ::google::protobuf::RepeatedField<double>* Data::mutable_parameters_previous()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Data.parameters_previous)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_parameters_previous();
}
inline const ::google::protobuf::RepeatedField<double>& Data::_internal_parameters_previous()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_previous_;
}
inline ::google::protobuf::RepeatedField<double>* Data::_internal_mutable_parameters_previous() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.parameters_previous_;
}

// -------------------------------------------------------------------

// DataRequest

// int32 index = 1;
inline void DataRequest::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = 0;
}
inline ::int32_t DataRequest::index() const {
  // @@protoc_insertion_point(field_get:direct.DataRequest.index)
  return _internal_index();
}
inline void DataRequest::set_index(::int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:direct.DataRequest.index)
}
inline ::int32_t DataRequest::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void DataRequest::_internal_set_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.index_ = value;
}

// .direct.Data data = 2;
inline bool DataRequest::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void DataRequest::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::direct::Data& DataRequest::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::direct::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::direct::Data&>(::direct::_Data_default_instance_);
}
inline const ::direct::Data& DataRequest::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.DataRequest.data)
  return _internal_data();
}
inline void DataRequest::unsafe_arena_set_allocated_data(::direct::Data* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::direct::Data*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:direct.DataRequest.data)
}
inline ::direct::Data* DataRequest::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Data* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::direct::Data* DataRequest::unsafe_arena_release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.DataRequest.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::direct::Data* DataRequest::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::direct::Data>(GetArena());
    _impl_.data_ = reinterpret_cast<::direct::Data*>(p);
  }
  return _impl_.data_;
}
inline ::direct::Data* DataRequest::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::direct::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:direct.DataRequest.data)
  return _msg;
}
inline void DataRequest::set_allocated_data(::direct::Data* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::direct::Data*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::direct::Data*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::direct::Data*>(value);
  // @@protoc_insertion_point(field_set_allocated:direct.DataRequest.data)
}

// -------------------------------------------------------------------

// DataResponse

// .direct.Data data = 1;
inline bool DataResponse::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void DataResponse::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::direct::Data& DataResponse::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::direct::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::direct::Data&>(::direct::_Data_default_instance_);
}
inline const ::direct::Data& DataResponse::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.DataResponse.data)
  return _internal_data();
}
inline void DataResponse::unsafe_arena_set_allocated_data(::direct::Data* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::direct::Data*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:direct.DataResponse.data)
}
inline ::direct::Data* DataResponse::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Data* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::direct::Data* DataResponse::unsafe_arena_release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.DataResponse.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::direct::Data* DataResponse::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::direct::Data>(GetArena());
    _impl_.data_ = reinterpret_cast<::direct::Data*>(p);
  }
  return _impl_.data_;
}
inline ::direct::Data* DataResponse::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::direct::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:direct.DataResponse.data)
  return _msg;
}
inline void DataResponse::set_allocated_data(::direct::Data* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::direct::Data*>(_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::direct::Data*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::direct::Data*>(value);
  // @@protoc_insertion_point(field_set_allocated:direct.DataResponse.data)
}

// -------------------------------------------------------------------

// Settings

// optional int32 configuration_length = 1;
inline bool Settings::has_configuration_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Settings::clear_configuration_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.configuration_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Settings::configuration_length() const {
  // @@protoc_insertion_point(field_get:direct.Settings.configuration_length)
  return _internal_configuration_length();
}
inline void Settings::set_configuration_length(::int32_t value) {
  _internal_set_configuration_length(value);
  // @@protoc_insertion_point(field_set:direct.Settings.configuration_length)
}
inline ::int32_t Settings::_internal_configuration_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.configuration_length_;
}
inline void Settings::_internal_set_configuration_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.configuration_length_ = value;
}

// optional bool sensor_flag = 2;
inline bool Settings::has_sensor_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Settings::clear_sensor_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_flag_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Settings::sensor_flag() const {
  // @@protoc_insertion_point(field_get:direct.Settings.sensor_flag)
  return _internal_sensor_flag();
}
inline void Settings::set_sensor_flag(bool value) {
  _internal_set_sensor_flag(value);
  // @@protoc_insertion_point(field_set:direct.Settings.sensor_flag)
}
inline bool Settings::_internal_sensor_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_flag_;
}
inline void Settings::_internal_set_sensor_flag(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sensor_flag_ = value;
}

// optional bool force_flag = 3;
inline bool Settings::has_force_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Settings::clear_force_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_flag_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Settings::force_flag() const {
  // @@protoc_insertion_point(field_get:direct.Settings.force_flag)
  return _internal_force_flag();
}
inline void Settings::set_force_flag(bool value) {
  _internal_set_force_flag(value);
  // @@protoc_insertion_point(field_set:direct.Settings.force_flag)
}
inline bool Settings::_internal_force_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_flag_;
}
inline void Settings::_internal_set_force_flag(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.force_flag_ = value;
}

// optional int32 max_search_iterations = 4;
inline bool Settings::has_max_search_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Settings::clear_max_search_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_search_iterations_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Settings::max_search_iterations() const {
  // @@protoc_insertion_point(field_get:direct.Settings.max_search_iterations)
  return _internal_max_search_iterations();
}
inline void Settings::set_max_search_iterations(::int32_t value) {
  _internal_set_max_search_iterations(value);
  // @@protoc_insertion_point(field_set:direct.Settings.max_search_iterations)
}
inline ::int32_t Settings::_internal_max_search_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_search_iterations_;
}
inline void Settings::_internal_set_max_search_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_search_iterations_ = value;
}

// optional int32 max_smoother_iterations = 5;
inline bool Settings::has_max_smoother_iterations() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Settings::clear_max_smoother_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_smoother_iterations_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t Settings::max_smoother_iterations() const {
  // @@protoc_insertion_point(field_get:direct.Settings.max_smoother_iterations)
  return _internal_max_smoother_iterations();
}
inline void Settings::set_max_smoother_iterations(::int32_t value) {
  _internal_set_max_smoother_iterations(value);
  // @@protoc_insertion_point(field_set:direct.Settings.max_smoother_iterations)
}
inline ::int32_t Settings::_internal_max_smoother_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_smoother_iterations_;
}
inline void Settings::_internal_set_max_smoother_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_smoother_iterations_ = value;
}

// optional double gradient_tolerance = 6;
inline bool Settings::has_gradient_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void Settings::clear_gradient_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gradient_tolerance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline double Settings::gradient_tolerance() const {
  // @@protoc_insertion_point(field_get:direct.Settings.gradient_tolerance)
  return _internal_gradient_tolerance();
}
inline void Settings::set_gradient_tolerance(double value) {
  _internal_set_gradient_tolerance(value);
  // @@protoc_insertion_point(field_set:direct.Settings.gradient_tolerance)
}
inline double Settings::_internal_gradient_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gradient_tolerance_;
}
inline void Settings::_internal_set_gradient_tolerance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.gradient_tolerance_ = value;
}

// optional bool verbose_iteration = 7;
inline bool Settings::has_verbose_iteration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Settings::clear_verbose_iteration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbose_iteration_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Settings::verbose_iteration() const {
  // @@protoc_insertion_point(field_get:direct.Settings.verbose_iteration)
  return _internal_verbose_iteration();
}
inline void Settings::set_verbose_iteration(bool value) {
  _internal_set_verbose_iteration(value);
  // @@protoc_insertion_point(field_set:direct.Settings.verbose_iteration)
}
inline bool Settings::_internal_verbose_iteration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbose_iteration_;
}
inline void Settings::_internal_set_verbose_iteration(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.verbose_iteration_ = value;
}

// optional bool verbose_optimize = 8;
inline bool Settings::has_verbose_optimize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Settings::clear_verbose_optimize() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbose_optimize_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Settings::verbose_optimize() const {
  // @@protoc_insertion_point(field_get:direct.Settings.verbose_optimize)
  return _internal_verbose_optimize();
}
inline void Settings::set_verbose_optimize(bool value) {
  _internal_set_verbose_optimize(value);
  // @@protoc_insertion_point(field_set:direct.Settings.verbose_optimize)
}
inline bool Settings::_internal_verbose_optimize() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbose_optimize_;
}
inline void Settings::_internal_set_verbose_optimize(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.verbose_optimize_ = value;
}

// optional bool verbose_cost = 9;
inline bool Settings::has_verbose_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void Settings::clear_verbose_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbose_cost_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool Settings::verbose_cost() const {
  // @@protoc_insertion_point(field_get:direct.Settings.verbose_cost)
  return _internal_verbose_cost();
}
inline void Settings::set_verbose_cost(bool value) {
  _internal_set_verbose_cost(value);
  // @@protoc_insertion_point(field_set:direct.Settings.verbose_cost)
}
inline bool Settings::_internal_verbose_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbose_cost_;
}
inline void Settings::_internal_set_verbose_cost(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.verbose_cost_ = value;
}

// optional int32 search_type = 10;
inline bool Settings::has_search_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void Settings::clear_search_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t Settings::search_type() const {
  // @@protoc_insertion_point(field_get:direct.Settings.search_type)
  return _internal_search_type();
}
inline void Settings::set_search_type(::int32_t value) {
  _internal_set_search_type(value);
  // @@protoc_insertion_point(field_set:direct.Settings.search_type)
}
inline ::int32_t Settings::_internal_search_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_type_;
}
inline void Settings::_internal_set_search_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.search_type_ = value;
}

// optional double step_scaling = 11;
inline bool Settings::has_step_scaling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void Settings::clear_step_scaling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.step_scaling_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline double Settings::step_scaling() const {
  // @@protoc_insertion_point(field_get:direct.Settings.step_scaling)
  return _internal_step_scaling();
}
inline void Settings::set_step_scaling(double value) {
  _internal_set_step_scaling(value);
  // @@protoc_insertion_point(field_set:direct.Settings.step_scaling)
}
inline double Settings::_internal_step_scaling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.step_scaling_;
}
inline void Settings::_internal_set_step_scaling(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.step_scaling_ = value;
}

// optional double regularization_initial = 12;
inline bool Settings::has_regularization_initial() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void Settings::clear_regularization_initial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.regularization_initial_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline double Settings::regularization_initial() const {
  // @@protoc_insertion_point(field_get:direct.Settings.regularization_initial)
  return _internal_regularization_initial();
}
inline void Settings::set_regularization_initial(double value) {
  _internal_set_regularization_initial(value);
  // @@protoc_insertion_point(field_set:direct.Settings.regularization_initial)
}
inline double Settings::_internal_regularization_initial() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.regularization_initial_;
}
inline void Settings::_internal_set_regularization_initial(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.regularization_initial_ = value;
}

// optional double regularization_scaling = 13;
inline bool Settings::has_regularization_scaling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void Settings::clear_regularization_scaling() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.regularization_scaling_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline double Settings::regularization_scaling() const {
  // @@protoc_insertion_point(field_get:direct.Settings.regularization_scaling)
  return _internal_regularization_scaling();
}
inline void Settings::set_regularization_scaling(double value) {
  _internal_set_regularization_scaling(value);
  // @@protoc_insertion_point(field_set:direct.Settings.regularization_scaling)
}
inline double Settings::_internal_regularization_scaling() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.regularization_scaling_;
}
inline void Settings::_internal_set_regularization_scaling(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.regularization_scaling_ = value;
}

// optional bool time_scaling_force = 14;
inline bool Settings::has_time_scaling_force() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void Settings::clear_time_scaling_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_scaling_force_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool Settings::time_scaling_force() const {
  // @@protoc_insertion_point(field_get:direct.Settings.time_scaling_force)
  return _internal_time_scaling_force();
}
inline void Settings::set_time_scaling_force(bool value) {
  _internal_set_time_scaling_force(value);
  // @@protoc_insertion_point(field_set:direct.Settings.time_scaling_force)
}
inline bool Settings::_internal_time_scaling_force() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_scaling_force_;
}
inline void Settings::_internal_set_time_scaling_force(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.time_scaling_force_ = value;
}

// optional bool time_scaling_sensor = 15;
inline bool Settings::has_time_scaling_sensor() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void Settings::clear_time_scaling_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_scaling_sensor_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool Settings::time_scaling_sensor() const {
  // @@protoc_insertion_point(field_get:direct.Settings.time_scaling_sensor)
  return _internal_time_scaling_sensor();
}
inline void Settings::set_time_scaling_sensor(bool value) {
  _internal_set_time_scaling_sensor(value);
  // @@protoc_insertion_point(field_set:direct.Settings.time_scaling_sensor)
}
inline bool Settings::_internal_time_scaling_sensor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_scaling_sensor_;
}
inline void Settings::_internal_set_time_scaling_sensor(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.time_scaling_sensor_ = value;
}

// optional double search_direction_tolerance = 16;
inline bool Settings::has_search_direction_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void Settings::clear_search_direction_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_direction_tolerance_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline double Settings::search_direction_tolerance() const {
  // @@protoc_insertion_point(field_get:direct.Settings.search_direction_tolerance)
  return _internal_search_direction_tolerance();
}
inline void Settings::set_search_direction_tolerance(double value) {
  _internal_set_search_direction_tolerance(value);
  // @@protoc_insertion_point(field_set:direct.Settings.search_direction_tolerance)
}
inline double Settings::_internal_search_direction_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_direction_tolerance_;
}
inline void Settings::_internal_set_search_direction_tolerance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.search_direction_tolerance_ = value;
}

// optional double cost_tolerance = 17;
inline bool Settings::has_cost_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void Settings::clear_cost_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cost_tolerance_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline double Settings::cost_tolerance() const {
  // @@protoc_insertion_point(field_get:direct.Settings.cost_tolerance)
  return _internal_cost_tolerance();
}
inline void Settings::set_cost_tolerance(double value) {
  _internal_set_cost_tolerance(value);
  // @@protoc_insertion_point(field_set:direct.Settings.cost_tolerance)
}
inline double Settings::_internal_cost_tolerance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_tolerance_;
}
inline void Settings::_internal_set_cost_tolerance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.cost_tolerance_ = value;
}

// optional bool assemble_sensor_jacobian = 18;
inline bool Settings::has_assemble_sensor_jacobian() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void Settings::clear_assemble_sensor_jacobian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assemble_sensor_jacobian_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool Settings::assemble_sensor_jacobian() const {
  // @@protoc_insertion_point(field_get:direct.Settings.assemble_sensor_jacobian)
  return _internal_assemble_sensor_jacobian();
}
inline void Settings::set_assemble_sensor_jacobian(bool value) {
  _internal_set_assemble_sensor_jacobian(value);
  // @@protoc_insertion_point(field_set:direct.Settings.assemble_sensor_jacobian)
}
inline bool Settings::_internal_assemble_sensor_jacobian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assemble_sensor_jacobian_;
}
inline void Settings::_internal_set_assemble_sensor_jacobian(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.assemble_sensor_jacobian_ = value;
}

// optional bool assemble_force_jacobian = 19;
inline bool Settings::has_assemble_force_jacobian() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void Settings::clear_assemble_force_jacobian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assemble_force_jacobian_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool Settings::assemble_force_jacobian() const {
  // @@protoc_insertion_point(field_get:direct.Settings.assemble_force_jacobian)
  return _internal_assemble_force_jacobian();
}
inline void Settings::set_assemble_force_jacobian(bool value) {
  _internal_set_assemble_force_jacobian(value);
  // @@protoc_insertion_point(field_set:direct.Settings.assemble_force_jacobian)
}
inline bool Settings::_internal_assemble_force_jacobian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assemble_force_jacobian_;
}
inline void Settings::_internal_set_assemble_force_jacobian(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.assemble_force_jacobian_ = value;
}

// optional bool assemble_sensor_norm_hessian = 20;
inline bool Settings::has_assemble_sensor_norm_hessian() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void Settings::clear_assemble_sensor_norm_hessian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assemble_sensor_norm_hessian_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool Settings::assemble_sensor_norm_hessian() const {
  // @@protoc_insertion_point(field_get:direct.Settings.assemble_sensor_norm_hessian)
  return _internal_assemble_sensor_norm_hessian();
}
inline void Settings::set_assemble_sensor_norm_hessian(bool value) {
  _internal_set_assemble_sensor_norm_hessian(value);
  // @@protoc_insertion_point(field_set:direct.Settings.assemble_sensor_norm_hessian)
}
inline bool Settings::_internal_assemble_sensor_norm_hessian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assemble_sensor_norm_hessian_;
}
inline void Settings::_internal_set_assemble_sensor_norm_hessian(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.assemble_sensor_norm_hessian_ = value;
}

// optional bool assemble_force_norm_hessian = 21;
inline bool Settings::has_assemble_force_norm_hessian() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void Settings::clear_assemble_force_norm_hessian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assemble_force_norm_hessian_ = false;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline bool Settings::assemble_force_norm_hessian() const {
  // @@protoc_insertion_point(field_get:direct.Settings.assemble_force_norm_hessian)
  return _internal_assemble_force_norm_hessian();
}
inline void Settings::set_assemble_force_norm_hessian(bool value) {
  _internal_set_assemble_force_norm_hessian(value);
  // @@protoc_insertion_point(field_set:direct.Settings.assemble_force_norm_hessian)
}
inline bool Settings::_internal_assemble_force_norm_hessian() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assemble_force_norm_hessian_;
}
inline void Settings::_internal_set_assemble_force_norm_hessian(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.assemble_force_norm_hessian_ = value;
}

// optional bool first_step_position_sensors = 22;
inline bool Settings::has_first_step_position_sensors() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void Settings::clear_first_step_position_sensors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.first_step_position_sensors_ = false;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline bool Settings::first_step_position_sensors() const {
  // @@protoc_insertion_point(field_get:direct.Settings.first_step_position_sensors)
  return _internal_first_step_position_sensors();
}
inline void Settings::set_first_step_position_sensors(bool value) {
  _internal_set_first_step_position_sensors(value);
  // @@protoc_insertion_point(field_set:direct.Settings.first_step_position_sensors)
}
inline bool Settings::_internal_first_step_position_sensors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.first_step_position_sensors_;
}
inline void Settings::_internal_set_first_step_position_sensors(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.first_step_position_sensors_ = value;
}

// optional bool last_step_position_sensors = 23;
inline bool Settings::has_last_step_position_sensors() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void Settings::clear_last_step_position_sensors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_step_position_sensors_ = false;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline bool Settings::last_step_position_sensors() const {
  // @@protoc_insertion_point(field_get:direct.Settings.last_step_position_sensors)
  return _internal_last_step_position_sensors();
}
inline void Settings::set_last_step_position_sensors(bool value) {
  _internal_set_last_step_position_sensors(value);
  // @@protoc_insertion_point(field_set:direct.Settings.last_step_position_sensors)
}
inline bool Settings::_internal_last_step_position_sensors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_step_position_sensors_;
}
inline void Settings::_internal_set_last_step_position_sensors(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.last_step_position_sensors_ = value;
}

// optional bool last_step_velocity_sensors = 24;
inline bool Settings::has_last_step_velocity_sensors() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void Settings::clear_last_step_velocity_sensors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.last_step_velocity_sensors_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool Settings::last_step_velocity_sensors() const {
  // @@protoc_insertion_point(field_get:direct.Settings.last_step_velocity_sensors)
  return _internal_last_step_velocity_sensors();
}
inline void Settings::set_last_step_velocity_sensors(bool value) {
  _internal_set_last_step_velocity_sensors(value);
  // @@protoc_insertion_point(field_set:direct.Settings.last_step_velocity_sensors)
}
inline bool Settings::_internal_last_step_velocity_sensors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.last_step_velocity_sensors_;
}
inline void Settings::_internal_set_last_step_velocity_sensors(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.last_step_velocity_sensors_ = value;
}

// -------------------------------------------------------------------

// SettingsRequest

// optional .direct.Settings settings = 1;
inline bool SettingsRequest::has_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.settings_ != nullptr);
  return value;
}
inline void SettingsRequest::clear_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.settings_ != nullptr) _impl_.settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::direct::Settings& SettingsRequest::_internal_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::direct::Settings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::direct::Settings&>(::direct::_Settings_default_instance_);
}
inline const ::direct::Settings& SettingsRequest::settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.SettingsRequest.settings)
  return _internal_settings();
}
inline void SettingsRequest::unsafe_arena_set_allocated_settings(::direct::Settings* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = reinterpret_cast<::direct::Settings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:direct.SettingsRequest.settings)
}
inline ::direct::Settings* SettingsRequest::release_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Settings* released = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::direct::Settings* SettingsRequest::unsafe_arena_release_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.SettingsRequest.settings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Settings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::direct::Settings* SettingsRequest::_internal_mutable_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::direct::Settings>(GetArena());
    _impl_.settings_ = reinterpret_cast<::direct::Settings*>(p);
  }
  return _impl_.settings_;
}
inline ::direct::Settings* SettingsRequest::mutable_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::direct::Settings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:direct.SettingsRequest.settings)
  return _msg;
}
inline void SettingsRequest::set_allocated_settings(::direct::Settings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::direct::Settings*>(_impl_.settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::direct::Settings*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.settings_ = reinterpret_cast<::direct::Settings*>(value);
  // @@protoc_insertion_point(field_set_allocated:direct.SettingsRequest.settings)
}

// -------------------------------------------------------------------

// SettingsResponse

// .direct.Settings settings = 1;
inline bool SettingsResponse::has_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.settings_ != nullptr);
  return value;
}
inline void SettingsResponse::clear_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.settings_ != nullptr) _impl_.settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::direct::Settings& SettingsResponse::_internal_settings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::direct::Settings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::direct::Settings&>(::direct::_Settings_default_instance_);
}
inline const ::direct::Settings& SettingsResponse::settings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.SettingsResponse.settings)
  return _internal_settings();
}
inline void SettingsResponse::unsafe_arena_set_allocated_settings(::direct::Settings* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = reinterpret_cast<::direct::Settings*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:direct.SettingsResponse.settings)
}
inline ::direct::Settings* SettingsResponse::release_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Settings* released = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::direct::Settings* SettingsResponse::unsafe_arena_release_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.SettingsResponse.settings)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Settings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::direct::Settings* SettingsResponse::_internal_mutable_settings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::direct::Settings>(GetArena());
    _impl_.settings_ = reinterpret_cast<::direct::Settings*>(p);
  }
  return _impl_.settings_;
}
inline ::direct::Settings* SettingsResponse::mutable_settings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::direct::Settings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:direct.SettingsResponse.settings)
  return _msg;
}
inline void SettingsResponse::set_allocated_settings(::direct::Settings* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::direct::Settings*>(_impl_.settings_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::direct::Settings*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.settings_ = reinterpret_cast<::direct::Settings*>(value);
  // @@protoc_insertion_point(field_set_allocated:direct.SettingsResponse.settings)
}

// -------------------------------------------------------------------

// CostRequest

// optional bool derivatives = 1;
inline bool CostRequest::has_derivatives() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CostRequest::clear_derivatives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.derivatives_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CostRequest::derivatives() const {
  // @@protoc_insertion_point(field_get:direct.CostRequest.derivatives)
  return _internal_derivatives();
}
inline void CostRequest::set_derivatives(bool value) {
  _internal_set_derivatives(value);
  // @@protoc_insertion_point(field_set:direct.CostRequest.derivatives)
}
inline bool CostRequest::_internal_derivatives() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.derivatives_;
}
inline void CostRequest::_internal_set_derivatives(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.derivatives_ = value;
}

// optional bool internals = 2;
inline bool CostRequest::has_internals() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CostRequest::clear_internals() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.internals_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CostRequest::internals() const {
  // @@protoc_insertion_point(field_get:direct.CostRequest.internals)
  return _internal_internals();
}
inline void CostRequest::set_internals(bool value) {
  _internal_set_internals(value);
  // @@protoc_insertion_point(field_set:direct.CostRequest.internals)
}
inline bool CostRequest::_internal_internals() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.internals_;
}
inline void CostRequest::_internal_set_internals(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.internals_ = value;
}

// -------------------------------------------------------------------

// CostResponse

// double total = 1;
inline void CostResponse::clear_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_ = 0;
}
inline double CostResponse::total() const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.total)
  return _internal_total();
}
inline void CostResponse::set_total(double value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.total)
}
inline double CostResponse::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void CostResponse::_internal_set_total(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_ = value;
}

// double sensor = 2;
inline void CostResponse::clear_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_ = 0;
}
inline double CostResponse::sensor() const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.sensor)
  return _internal_sensor();
}
inline void CostResponse::set_sensor(double value) {
  _internal_set_sensor(value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.sensor)
}
inline double CostResponse::_internal_sensor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_;
}
inline void CostResponse::_internal_set_sensor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sensor_ = value;
}

// double force = 3;
inline void CostResponse::clear_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_ = 0;
}
inline double CostResponse::force() const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.force)
  return _internal_force();
}
inline void CostResponse::set_force(double value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.force)
}
inline double CostResponse::_internal_force() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_;
}
inline void CostResponse::_internal_set_force(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.force_ = value;
}

// double parameter = 4;
inline void CostResponse::clear_parameter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameter_ = 0;
}
inline double CostResponse::parameter() const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.parameter)
  return _internal_parameter();
}
inline void CostResponse::set_parameter(double value) {
  _internal_set_parameter(value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.parameter)
}
inline double CostResponse::_internal_parameter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameter_;
}
inline void CostResponse::_internal_set_parameter(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parameter_ = value;
}

// double initial = 5;
inline void CostResponse::clear_initial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initial_ = 0;
}
inline double CostResponse::initial() const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.initial)
  return _internal_initial();
}
inline void CostResponse::set_initial(double value) {
  _internal_set_initial(value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.initial)
}
inline double CostResponse::_internal_initial() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.initial_;
}
inline void CostResponse::_internal_set_initial(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.initial_ = value;
}

// repeated double gradient = 6 [packed = true];
inline int CostResponse::_internal_gradient_size() const {
  return _internal_gradient().size();
}
inline int CostResponse::gradient_size() const {
  return _internal_gradient_size();
}
inline void CostResponse::clear_gradient() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gradient_.Clear();
}
inline double CostResponse::gradient(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.gradient)
  return _internal_gradient().Get(index);
}
inline void CostResponse::set_gradient(int index, double value) {
  _internal_mutable_gradient()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.gradient)
}
inline void CostResponse::add_gradient(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_gradient()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.gradient)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::gradient() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.gradient)
  return _internal_gradient();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_gradient()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.gradient)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_gradient();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_gradient()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gradient_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_gradient() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.gradient_;
}

// repeated double hessian = 7 [packed = true];
inline int CostResponse::_internal_hessian_size() const {
  return _internal_hessian().size();
}
inline int CostResponse::hessian_size() const {
  return _internal_hessian_size();
}
inline void CostResponse::clear_hessian() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hessian_.Clear();
}
inline double CostResponse::hessian(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.hessian)
  return _internal_hessian().Get(index);
}
inline void CostResponse::set_hessian(int index, double value) {
  _internal_mutable_hessian()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.hessian)
}
inline void CostResponse::add_hessian(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_hessian()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.hessian)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::hessian() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.hessian)
  return _internal_hessian();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_hessian()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.hessian)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hessian();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_hessian()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hessian_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_hessian() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hessian_;
}

// repeated double residual_sensor = 8 [packed = true];
inline int CostResponse::_internal_residual_sensor_size() const {
  return _internal_residual_sensor().size();
}
inline int CostResponse::residual_sensor_size() const {
  return _internal_residual_sensor_size();
}
inline void CostResponse::clear_residual_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.residual_sensor_.Clear();
}
inline double CostResponse::residual_sensor(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.residual_sensor)
  return _internal_residual_sensor().Get(index);
}
inline void CostResponse::set_residual_sensor(int index, double value) {
  _internal_mutable_residual_sensor()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.residual_sensor)
}
inline void CostResponse::add_residual_sensor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_residual_sensor()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.residual_sensor)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::residual_sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.residual_sensor)
  return _internal_residual_sensor();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_residual_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.residual_sensor)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_residual_sensor();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_residual_sensor()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.residual_sensor_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_residual_sensor() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.residual_sensor_;
}

// repeated double residual_force = 9 [packed = true];
inline int CostResponse::_internal_residual_force_size() const {
  return _internal_residual_force().size();
}
inline int CostResponse::residual_force_size() const {
  return _internal_residual_force_size();
}
inline void CostResponse::clear_residual_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.residual_force_.Clear();
}
inline double CostResponse::residual_force(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.residual_force)
  return _internal_residual_force().Get(index);
}
inline void CostResponse::set_residual_force(int index, double value) {
  _internal_mutable_residual_force()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.residual_force)
}
inline void CostResponse::add_residual_force(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_residual_force()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.residual_force)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::residual_force() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.residual_force)
  return _internal_residual_force();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_residual_force()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.residual_force)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_residual_force();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_residual_force()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.residual_force_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_residual_force() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.residual_force_;
}

// repeated double jacobian_sensor = 10 [packed = true];
inline int CostResponse::_internal_jacobian_sensor_size() const {
  return _internal_jacobian_sensor().size();
}
inline int CostResponse::jacobian_sensor_size() const {
  return _internal_jacobian_sensor_size();
}
inline void CostResponse::clear_jacobian_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jacobian_sensor_.Clear();
}
inline double CostResponse::jacobian_sensor(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.jacobian_sensor)
  return _internal_jacobian_sensor().Get(index);
}
inline void CostResponse::set_jacobian_sensor(int index, double value) {
  _internal_mutable_jacobian_sensor()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.jacobian_sensor)
}
inline void CostResponse::add_jacobian_sensor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_jacobian_sensor()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.jacobian_sensor)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::jacobian_sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.jacobian_sensor)
  return _internal_jacobian_sensor();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_jacobian_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.jacobian_sensor)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jacobian_sensor();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_jacobian_sensor()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jacobian_sensor_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_jacobian_sensor() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jacobian_sensor_;
}

// repeated double jacobian_force = 11 [packed = true];
inline int CostResponse::_internal_jacobian_force_size() const {
  return _internal_jacobian_force().size();
}
inline int CostResponse::jacobian_force_size() const {
  return _internal_jacobian_force_size();
}
inline void CostResponse::clear_jacobian_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jacobian_force_.Clear();
}
inline double CostResponse::jacobian_force(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.jacobian_force)
  return _internal_jacobian_force().Get(index);
}
inline void CostResponse::set_jacobian_force(int index, double value) {
  _internal_mutable_jacobian_force()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.jacobian_force)
}
inline void CostResponse::add_jacobian_force(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_jacobian_force()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.jacobian_force)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::jacobian_force() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.jacobian_force)
  return _internal_jacobian_force();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_jacobian_force()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.jacobian_force)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_jacobian_force();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_jacobian_force()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jacobian_force_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_jacobian_force() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.jacobian_force_;
}

// repeated double norm_gradient_sensor = 12 [packed = true];
inline int CostResponse::_internal_norm_gradient_sensor_size() const {
  return _internal_norm_gradient_sensor().size();
}
inline int CostResponse::norm_gradient_sensor_size() const {
  return _internal_norm_gradient_sensor_size();
}
inline void CostResponse::clear_norm_gradient_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.norm_gradient_sensor_.Clear();
}
inline double CostResponse::norm_gradient_sensor(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.norm_gradient_sensor)
  return _internal_norm_gradient_sensor().Get(index);
}
inline void CostResponse::set_norm_gradient_sensor(int index, double value) {
  _internal_mutable_norm_gradient_sensor()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.norm_gradient_sensor)
}
inline void CostResponse::add_norm_gradient_sensor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_norm_gradient_sensor()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.norm_gradient_sensor)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::norm_gradient_sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.norm_gradient_sensor)
  return _internal_norm_gradient_sensor();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_norm_gradient_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.norm_gradient_sensor)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_norm_gradient_sensor();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_norm_gradient_sensor()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.norm_gradient_sensor_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_norm_gradient_sensor() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.norm_gradient_sensor_;
}

// repeated double norm_gradient_force = 13 [packed = true];
inline int CostResponse::_internal_norm_gradient_force_size() const {
  return _internal_norm_gradient_force().size();
}
inline int CostResponse::norm_gradient_force_size() const {
  return _internal_norm_gradient_force_size();
}
inline void CostResponse::clear_norm_gradient_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.norm_gradient_force_.Clear();
}
inline double CostResponse::norm_gradient_force(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.norm_gradient_force)
  return _internal_norm_gradient_force().Get(index);
}
inline void CostResponse::set_norm_gradient_force(int index, double value) {
  _internal_mutable_norm_gradient_force()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.norm_gradient_force)
}
inline void CostResponse::add_norm_gradient_force(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_norm_gradient_force()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.norm_gradient_force)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::norm_gradient_force() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.norm_gradient_force)
  return _internal_norm_gradient_force();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_norm_gradient_force()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.norm_gradient_force)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_norm_gradient_force();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_norm_gradient_force()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.norm_gradient_force_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_norm_gradient_force() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.norm_gradient_force_;
}

// repeated double norm_hessian_sensor = 14 [packed = true];
inline int CostResponse::_internal_norm_hessian_sensor_size() const {
  return _internal_norm_hessian_sensor().size();
}
inline int CostResponse::norm_hessian_sensor_size() const {
  return _internal_norm_hessian_sensor_size();
}
inline void CostResponse::clear_norm_hessian_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.norm_hessian_sensor_.Clear();
}
inline double CostResponse::norm_hessian_sensor(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.norm_hessian_sensor)
  return _internal_norm_hessian_sensor().Get(index);
}
inline void CostResponse::set_norm_hessian_sensor(int index, double value) {
  _internal_mutable_norm_hessian_sensor()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.norm_hessian_sensor)
}
inline void CostResponse::add_norm_hessian_sensor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_norm_hessian_sensor()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.norm_hessian_sensor)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::norm_hessian_sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.norm_hessian_sensor)
  return _internal_norm_hessian_sensor();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_norm_hessian_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.norm_hessian_sensor)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_norm_hessian_sensor();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_norm_hessian_sensor()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.norm_hessian_sensor_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_norm_hessian_sensor() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.norm_hessian_sensor_;
}

// repeated double norm_hessian_force = 15 [packed = true];
inline int CostResponse::_internal_norm_hessian_force_size() const {
  return _internal_norm_hessian_force().size();
}
inline int CostResponse::norm_hessian_force_size() const {
  return _internal_norm_hessian_force_size();
}
inline void CostResponse::clear_norm_hessian_force() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.norm_hessian_force_.Clear();
}
inline double CostResponse::norm_hessian_force(int index) const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.norm_hessian_force)
  return _internal_norm_hessian_force().Get(index);
}
inline void CostResponse::set_norm_hessian_force(int index, double value) {
  _internal_mutable_norm_hessian_force()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.norm_hessian_force)
}
inline void CostResponse::add_norm_hessian_force(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_norm_hessian_force()->Add(value);
  // @@protoc_insertion_point(field_add:direct.CostResponse.norm_hessian_force)
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::norm_hessian_force() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.CostResponse.norm_hessian_force)
  return _internal_norm_hessian_force();
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::mutable_norm_hessian_force()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.CostResponse.norm_hessian_force)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_norm_hessian_force();
}
inline const ::google::protobuf::RepeatedField<double>& CostResponse::_internal_norm_hessian_force()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.norm_hessian_force_;
}
inline ::google::protobuf::RepeatedField<double>* CostResponse::_internal_mutable_norm_hessian_force() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.norm_hessian_force_;
}

// int32 nvar = 16;
inline void CostResponse::clear_nvar() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nvar_ = 0;
}
inline ::int32_t CostResponse::nvar() const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.nvar)
  return _internal_nvar();
}
inline void CostResponse::set_nvar(::int32_t value) {
  _internal_set_nvar(value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.nvar)
}
inline ::int32_t CostResponse::_internal_nvar() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nvar_;
}
inline void CostResponse::_internal_set_nvar(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nvar_ = value;
}

// int32 nsensor = 17;
inline void CostResponse::clear_nsensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nsensor_ = 0;
}
inline ::int32_t CostResponse::nsensor() const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.nsensor)
  return _internal_nsensor();
}
inline void CostResponse::set_nsensor(::int32_t value) {
  _internal_set_nsensor(value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.nsensor)
}
inline ::int32_t CostResponse::_internal_nsensor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nsensor_;
}
inline void CostResponse::_internal_set_nsensor(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nsensor_ = value;
}

// int32 nforce = 18;
inline void CostResponse::clear_nforce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nforce_ = 0;
}
inline ::int32_t CostResponse::nforce() const {
  // @@protoc_insertion_point(field_get:direct.CostResponse.nforce)
  return _internal_nforce();
}
inline void CostResponse::set_nforce(::int32_t value) {
  _internal_set_nforce(value);
  // @@protoc_insertion_point(field_set:direct.CostResponse.nforce)
}
inline ::int32_t CostResponse::_internal_nforce() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nforce_;
}
inline void CostResponse::_internal_set_nforce(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nforce_ = value;
}

// -------------------------------------------------------------------

// Noise

// repeated double process = 1 [packed = true];
inline int Noise::_internal_process_size() const {
  return _internal_process().size();
}
inline int Noise::process_size() const {
  return _internal_process_size();
}
inline void Noise::clear_process() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_.Clear();
}
inline double Noise::process(int index) const {
  // @@protoc_insertion_point(field_get:direct.Noise.process)
  return _internal_process().Get(index);
}
inline void Noise::set_process(int index, double value) {
  _internal_mutable_process()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Noise.process)
}
inline void Noise::add_process(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_process()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Noise.process)
}
inline const ::google::protobuf::RepeatedField<double>& Noise::process() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Noise.process)
  return _internal_process();
}
inline ::google::protobuf::RepeatedField<double>* Noise::mutable_process()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Noise.process)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_process();
}
inline const ::google::protobuf::RepeatedField<double>& Noise::_internal_process()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.process_;
}
inline ::google::protobuf::RepeatedField<double>* Noise::_internal_mutable_process() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.process_;
}

// repeated double sensor = 2 [packed = true];
inline int Noise::_internal_sensor_size() const {
  return _internal_sensor().size();
}
inline int Noise::sensor_size() const {
  return _internal_sensor_size();
}
inline void Noise::clear_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_.Clear();
}
inline double Noise::sensor(int index) const {
  // @@protoc_insertion_point(field_get:direct.Noise.sensor)
  return _internal_sensor().Get(index);
}
inline void Noise::set_sensor(int index, double value) {
  _internal_mutable_sensor()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Noise.sensor)
}
inline void Noise::add_sensor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sensor()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Noise.sensor)
}
inline const ::google::protobuf::RepeatedField<double>& Noise::sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Noise.sensor)
  return _internal_sensor();
}
inline ::google::protobuf::RepeatedField<double>* Noise::mutable_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Noise.sensor)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sensor();
}
inline const ::google::protobuf::RepeatedField<double>& Noise::_internal_sensor()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_;
}
inline ::google::protobuf::RepeatedField<double>* Noise::_internal_mutable_sensor() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sensor_;
}

// repeated double parameter = 3 [packed = true];
inline int Noise::_internal_parameter_size() const {
  return _internal_parameter().size();
}
inline int Noise::parameter_size() const {
  return _internal_parameter_size();
}
inline void Noise::clear_parameter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameter_.Clear();
}
inline double Noise::parameter(int index) const {
  // @@protoc_insertion_point(field_get:direct.Noise.parameter)
  return _internal_parameter().Get(index);
}
inline void Noise::set_parameter(int index, double value) {
  _internal_mutable_parameter()->Set(index, value);
  // @@protoc_insertion_point(field_set:direct.Noise.parameter)
}
inline void Noise::add_parameter(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_parameter()->Add(value);
  // @@protoc_insertion_point(field_add:direct.Noise.parameter)
}
inline const ::google::protobuf::RepeatedField<double>& Noise::parameter() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:direct.Noise.parameter)
  return _internal_parameter();
}
inline ::google::protobuf::RepeatedField<double>* Noise::mutable_parameter()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:direct.Noise.parameter)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_parameter();
}
inline const ::google::protobuf::RepeatedField<double>& Noise::_internal_parameter()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameter_;
}
inline ::google::protobuf::RepeatedField<double>* Noise::_internal_mutable_parameter() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.parameter_;
}

// -------------------------------------------------------------------

// NoiseRequest

// optional .direct.Noise noise = 1;
inline bool NoiseRequest::has_noise() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.noise_ != nullptr);
  return value;
}
inline void NoiseRequest::clear_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.noise_ != nullptr) _impl_.noise_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::direct::Noise& NoiseRequest::_internal_noise() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::direct::Noise* p = _impl_.noise_;
  return p != nullptr ? *p : reinterpret_cast<const ::direct::Noise&>(::direct::_Noise_default_instance_);
}
inline const ::direct::Noise& NoiseRequest::noise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.NoiseRequest.noise)
  return _internal_noise();
}
inline void NoiseRequest::unsafe_arena_set_allocated_noise(::direct::Noise* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.noise_);
  }
  _impl_.noise_ = reinterpret_cast<::direct::Noise*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:direct.NoiseRequest.noise)
}
inline ::direct::Noise* NoiseRequest::release_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Noise* released = _impl_.noise_;
  _impl_.noise_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::direct::Noise* NoiseRequest::unsafe_arena_release_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.NoiseRequest.noise)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Noise* temp = _impl_.noise_;
  _impl_.noise_ = nullptr;
  return temp;
}
inline ::direct::Noise* NoiseRequest::_internal_mutable_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.noise_ == nullptr) {
    auto* p = CreateMaybeMessage<::direct::Noise>(GetArena());
    _impl_.noise_ = reinterpret_cast<::direct::Noise*>(p);
  }
  return _impl_.noise_;
}
inline ::direct::Noise* NoiseRequest::mutable_noise() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::direct::Noise* _msg = _internal_mutable_noise();
  // @@protoc_insertion_point(field_mutable:direct.NoiseRequest.noise)
  return _msg;
}
inline void NoiseRequest::set_allocated_noise(::direct::Noise* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::direct::Noise*>(_impl_.noise_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::direct::Noise*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.noise_ = reinterpret_cast<::direct::Noise*>(value);
  // @@protoc_insertion_point(field_set_allocated:direct.NoiseRequest.noise)
}

// -------------------------------------------------------------------

// NoiseResponse

// .direct.Noise noise = 1;
inline bool NoiseResponse::has_noise() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.noise_ != nullptr);
  return value;
}
inline void NoiseResponse::clear_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.noise_ != nullptr) _impl_.noise_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::direct::Noise& NoiseResponse::_internal_noise() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::direct::Noise* p = _impl_.noise_;
  return p != nullptr ? *p : reinterpret_cast<const ::direct::Noise&>(::direct::_Noise_default_instance_);
}
inline const ::direct::Noise& NoiseResponse::noise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.NoiseResponse.noise)
  return _internal_noise();
}
inline void NoiseResponse::unsafe_arena_set_allocated_noise(::direct::Noise* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.noise_);
  }
  _impl_.noise_ = reinterpret_cast<::direct::Noise*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:direct.NoiseResponse.noise)
}
inline ::direct::Noise* NoiseResponse::release_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Noise* released = _impl_.noise_;
  _impl_.noise_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::direct::Noise* NoiseResponse::unsafe_arena_release_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.NoiseResponse.noise)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Noise* temp = _impl_.noise_;
  _impl_.noise_ = nullptr;
  return temp;
}
inline ::direct::Noise* NoiseResponse::_internal_mutable_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.noise_ == nullptr) {
    auto* p = CreateMaybeMessage<::direct::Noise>(GetArena());
    _impl_.noise_ = reinterpret_cast<::direct::Noise*>(p);
  }
  return _impl_.noise_;
}
inline ::direct::Noise* NoiseResponse::mutable_noise() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::direct::Noise* _msg = _internal_mutable_noise();
  // @@protoc_insertion_point(field_mutable:direct.NoiseResponse.noise)
  return _msg;
}
inline void NoiseResponse::set_allocated_noise(::direct::Noise* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::direct::Noise*>(_impl_.noise_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::direct::Noise*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.noise_ = reinterpret_cast<::direct::Noise*>(value);
  // @@protoc_insertion_point(field_set_allocated:direct.NoiseResponse.noise)
}

// -------------------------------------------------------------------

// ResetRequest

// -------------------------------------------------------------------

// ResetResponse

// -------------------------------------------------------------------

// OptimizeRequest

// -------------------------------------------------------------------

// OptimizeResponse

// -------------------------------------------------------------------

// Status

// int32 search_iterations = 1;
inline void Status::clear_search_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_iterations_ = 0;
}
inline ::int32_t Status::search_iterations() const {
  // @@protoc_insertion_point(field_get:direct.Status.search_iterations)
  return _internal_search_iterations();
}
inline void Status::set_search_iterations(::int32_t value) {
  _internal_set_search_iterations(value);
  // @@protoc_insertion_point(field_set:direct.Status.search_iterations)
}
inline ::int32_t Status::_internal_search_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_iterations_;
}
inline void Status::_internal_set_search_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_iterations_ = value;
}

// int32 smoother_iterations = 2;
inline void Status::clear_smoother_iterations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.smoother_iterations_ = 0;
}
inline ::int32_t Status::smoother_iterations() const {
  // @@protoc_insertion_point(field_get:direct.Status.smoother_iterations)
  return _internal_smoother_iterations();
}
inline void Status::set_smoother_iterations(::int32_t value) {
  _internal_set_smoother_iterations(value);
  // @@protoc_insertion_point(field_set:direct.Status.smoother_iterations)
}
inline ::int32_t Status::_internal_smoother_iterations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.smoother_iterations_;
}
inline void Status::_internal_set_smoother_iterations(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.smoother_iterations_ = value;
}

// double step_size = 3;
inline void Status::clear_step_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.step_size_ = 0;
}
inline double Status::step_size() const {
  // @@protoc_insertion_point(field_get:direct.Status.step_size)
  return _internal_step_size();
}
inline void Status::set_step_size(double value) {
  _internal_set_step_size(value);
  // @@protoc_insertion_point(field_set:direct.Status.step_size)
}
inline double Status::_internal_step_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.step_size_;
}
inline void Status::_internal_set_step_size(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.step_size_ = value;
}

// double regularization = 4;
inline void Status::clear_regularization() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.regularization_ = 0;
}
inline double Status::regularization() const {
  // @@protoc_insertion_point(field_get:direct.Status.regularization)
  return _internal_regularization();
}
inline void Status::set_regularization(double value) {
  _internal_set_regularization(value);
  // @@protoc_insertion_point(field_set:direct.Status.regularization)
}
inline double Status::_internal_regularization() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.regularization_;
}
inline void Status::_internal_set_regularization(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.regularization_ = value;
}

// double gradient_norm = 5;
inline void Status::clear_gradient_norm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gradient_norm_ = 0;
}
inline double Status::gradient_norm() const {
  // @@protoc_insertion_point(field_get:direct.Status.gradient_norm)
  return _internal_gradient_norm();
}
inline void Status::set_gradient_norm(double value) {
  _internal_set_gradient_norm(value);
  // @@protoc_insertion_point(field_set:direct.Status.gradient_norm)
}
inline double Status::_internal_gradient_norm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gradient_norm_;
}
inline void Status::_internal_set_gradient_norm(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gradient_norm_ = value;
}

// double search_direction_norm = 6;
inline void Status::clear_search_direction_norm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_direction_norm_ = 0;
}
inline double Status::search_direction_norm() const {
  // @@protoc_insertion_point(field_get:direct.Status.search_direction_norm)
  return _internal_search_direction_norm();
}
inline void Status::set_search_direction_norm(double value) {
  _internal_set_search_direction_norm(value);
  // @@protoc_insertion_point(field_set:direct.Status.search_direction_norm)
}
inline double Status::_internal_search_direction_norm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_direction_norm_;
}
inline void Status::_internal_set_search_direction_norm(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_direction_norm_ = value;
}

// int32 solve_status = 7;
inline void Status::clear_solve_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.solve_status_ = 0;
}
inline ::int32_t Status::solve_status() const {
  // @@protoc_insertion_point(field_get:direct.Status.solve_status)
  return _internal_solve_status();
}
inline void Status::set_solve_status(::int32_t value) {
  _internal_set_solve_status(value);
  // @@protoc_insertion_point(field_set:direct.Status.solve_status)
}
inline ::int32_t Status::_internal_solve_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.solve_status_;
}
inline void Status::_internal_set_solve_status(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.solve_status_ = value;
}

// double cost_difference = 8;
inline void Status::clear_cost_difference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cost_difference_ = 0;
}
inline double Status::cost_difference() const {
  // @@protoc_insertion_point(field_get:direct.Status.cost_difference)
  return _internal_cost_difference();
}
inline void Status::set_cost_difference(double value) {
  _internal_set_cost_difference(value);
  // @@protoc_insertion_point(field_set:direct.Status.cost_difference)
}
inline double Status::_internal_cost_difference() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_difference_;
}
inline void Status::_internal_set_cost_difference(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cost_difference_ = value;
}

// double improvement = 9;
inline void Status::clear_improvement() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.improvement_ = 0;
}
inline double Status::improvement() const {
  // @@protoc_insertion_point(field_get:direct.Status.improvement)
  return _internal_improvement();
}
inline void Status::set_improvement(double value) {
  _internal_set_improvement(value);
  // @@protoc_insertion_point(field_set:direct.Status.improvement)
}
inline double Status::_internal_improvement() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.improvement_;
}
inline void Status::_internal_set_improvement(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.improvement_ = value;
}

// double expected = 10;
inline void Status::clear_expected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expected_ = 0;
}
inline double Status::expected() const {
  // @@protoc_insertion_point(field_get:direct.Status.expected)
  return _internal_expected();
}
inline void Status::set_expected(double value) {
  _internal_set_expected(value);
  // @@protoc_insertion_point(field_set:direct.Status.expected)
}
inline double Status::_internal_expected() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expected_;
}
inline void Status::_internal_set_expected(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.expected_ = value;
}

// double reduction_ratio = 11;
inline void Status::clear_reduction_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reduction_ratio_ = 0;
}
inline double Status::reduction_ratio() const {
  // @@protoc_insertion_point(field_get:direct.Status.reduction_ratio)
  return _internal_reduction_ratio();
}
inline void Status::set_reduction_ratio(double value) {
  _internal_set_reduction_ratio(value);
  // @@protoc_insertion_point(field_set:direct.Status.reduction_ratio)
}
inline double Status::_internal_reduction_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reduction_ratio_;
}
inline void Status::_internal_set_reduction_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reduction_ratio_ = value;
}

// -------------------------------------------------------------------

// StatusRequest

// -------------------------------------------------------------------

// StatusResponse

// .direct.Status status = 1;
inline bool StatusResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void StatusResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::direct::Status& StatusResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::direct::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::direct::Status&>(::direct::_Status_default_instance_);
}
inline const ::direct::Status& StatusResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:direct.StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::unsafe_arena_set_allocated_status(::direct::Status* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::direct::Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:direct.StatusResponse.status)
}
inline ::direct::Status* StatusResponse::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::direct::Status* StatusResponse::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:direct.StatusResponse.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::direct::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::direct::Status* StatusResponse::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::direct::Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::direct::Status*>(p);
  }
  return _impl_.status_;
}
inline ::direct::Status* StatusResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::direct::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:direct.StatusResponse.status)
  return _msg;
}
inline void StatusResponse::set_allocated_status(::direct::Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::direct::Status*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::direct::Status*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::direct::Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:direct.StatusResponse.status)
}

// -------------------------------------------------------------------

// SensorInfoRequest

// -------------------------------------------------------------------

// SensorInfoResponse

// int32 start_index = 1;
inline void SensorInfoResponse::clear_start_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_index_ = 0;
}
inline ::int32_t SensorInfoResponse::start_index() const {
  // @@protoc_insertion_point(field_get:direct.SensorInfoResponse.start_index)
  return _internal_start_index();
}
inline void SensorInfoResponse::set_start_index(::int32_t value) {
  _internal_set_start_index(value);
  // @@protoc_insertion_point(field_set:direct.SensorInfoResponse.start_index)
}
inline ::int32_t SensorInfoResponse::_internal_start_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_index_;
}
inline void SensorInfoResponse::_internal_set_start_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_index_ = value;
}

// int32 num_measurements = 2;
inline void SensorInfoResponse::clear_num_measurements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_measurements_ = 0;
}
inline ::int32_t SensorInfoResponse::num_measurements() const {
  // @@protoc_insertion_point(field_get:direct.SensorInfoResponse.num_measurements)
  return _internal_num_measurements();
}
inline void SensorInfoResponse::set_num_measurements(::int32_t value) {
  _internal_set_num_measurements(value);
  // @@protoc_insertion_point(field_set:direct.SensorInfoResponse.num_measurements)
}
inline ::int32_t SensorInfoResponse::_internal_num_measurements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_measurements_;
}
inline void SensorInfoResponse::_internal_set_num_measurements(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_measurements_ = value;
}

// int32 dim_measurements = 3;
inline void SensorInfoResponse::clear_dim_measurements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dim_measurements_ = 0;
}
inline ::int32_t SensorInfoResponse::dim_measurements() const {
  // @@protoc_insertion_point(field_get:direct.SensorInfoResponse.dim_measurements)
  return _internal_dim_measurements();
}
inline void SensorInfoResponse::set_dim_measurements(::int32_t value) {
  _internal_set_dim_measurements(value);
  // @@protoc_insertion_point(field_set:direct.SensorInfoResponse.dim_measurements)
}
inline ::int32_t SensorInfoResponse::_internal_dim_measurements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dim_measurements_;
}
inline void SensorInfoResponse::_internal_set_dim_measurements(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dim_measurements_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace direct


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_direct_2eproto_2epb_2eh
