// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: filter.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_filter_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_filter_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_filter_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_filter_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_filter_2eproto;
namespace filter {
class Covariance;
struct CovarianceDefaultTypeInternal;
extern CovarianceDefaultTypeInternal _Covariance_default_instance_;
class CovarianceRequest;
struct CovarianceRequestDefaultTypeInternal;
extern CovarianceRequestDefaultTypeInternal _CovarianceRequest_default_instance_;
class CovarianceResponse;
struct CovarianceResponseDefaultTypeInternal;
extern CovarianceResponseDefaultTypeInternal _CovarianceResponse_default_instance_;
class InitRequest;
struct InitRequestDefaultTypeInternal;
extern InitRequestDefaultTypeInternal _InitRequest_default_instance_;
class InitResponse;
struct InitResponseDefaultTypeInternal;
extern InitResponseDefaultTypeInternal _InitResponse_default_instance_;
class MjModel;
struct MjModelDefaultTypeInternal;
extern MjModelDefaultTypeInternal _MjModel_default_instance_;
class Noise;
struct NoiseDefaultTypeInternal;
extern NoiseDefaultTypeInternal _Noise_default_instance_;
class NoiseRequest;
struct NoiseRequestDefaultTypeInternal;
extern NoiseRequestDefaultTypeInternal _NoiseRequest_default_instance_;
class NoiseResponse;
struct NoiseResponseDefaultTypeInternal;
extern NoiseResponseDefaultTypeInternal _NoiseResponse_default_instance_;
class ResetRequest;
struct ResetRequestDefaultTypeInternal;
extern ResetRequestDefaultTypeInternal _ResetRequest_default_instance_;
class ResetResponse;
struct ResetResponseDefaultTypeInternal;
extern ResetResponseDefaultTypeInternal _ResetResponse_default_instance_;
class State;
struct StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class StateRequest;
struct StateRequestDefaultTypeInternal;
extern StateRequestDefaultTypeInternal _StateRequest_default_instance_;
class StateResponse;
struct StateResponseDefaultTypeInternal;
extern StateResponseDefaultTypeInternal _StateResponse_default_instance_;
class UpdateRequest;
struct UpdateRequestDefaultTypeInternal;
extern UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
class UpdateResponse;
struct UpdateResponseDefaultTypeInternal;
extern UpdateResponseDefaultTypeInternal _UpdateResponse_default_instance_;
}  // namespace filter
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace filter {

// ===================================================================


// -------------------------------------------------------------------

class UpdateResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:filter.UpdateResponse) */ {
 public:
  inline UpdateResponse() : UpdateResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateResponse(::google::protobuf::internal::ConstantInitialized);

  inline UpdateResponse(const UpdateResponse& from)
      : UpdateResponse(nullptr, from) {}
  UpdateResponse(UpdateResponse&& from) noexcept
    : UpdateResponse() {
    *this = ::std::move(from);
  }

  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateResponse& operator=(UpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateResponse*>(
               &_UpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateResponse& a, UpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.UpdateResponse";
  }
  protected:
  explicit UpdateResponse(::google::protobuf::Arena* arena);
  UpdateResponse(::google::protobuf::Arena* arena, const UpdateResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:filter.UpdateResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class UpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.UpdateRequest) */ {
 public:
  inline UpdateRequest() : UpdateRequest(nullptr) {}
  ~UpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateRequest(const UpdateRequest& from)
      : UpdateRequest(nullptr, from) {}
  UpdateRequest(UpdateRequest&& from) noexcept
    : UpdateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRequest& operator=(UpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRequest*>(
               &_UpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateRequest& a, UpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateRequest& from) {
    UpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.UpdateRequest";
  }
  protected:
  explicit UpdateRequest(::google::protobuf::Arena* arena);
  UpdateRequest(::google::protobuf::Arena* arena, const UpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlFieldNumber = 1,
    kSensorFieldNumber = 2,
    kModeFieldNumber = 3,
  };
  // repeated double ctrl = 1 [packed = true];
  int ctrl_size() const;
  private:
  int _internal_ctrl_size() const;

  public:
  void clear_ctrl() ;
  double ctrl(int index) const;
  void set_ctrl(int index, double value);
  void add_ctrl(double value);
  const ::google::protobuf::RepeatedField<double>& ctrl() const;
  ::google::protobuf::RepeatedField<double>* mutable_ctrl();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_ctrl() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_ctrl();

  public:
  // repeated double sensor = 2 [packed = true];
  int sensor_size() const;
  private:
  int _internal_sensor_size() const;

  public:
  void clear_sensor() ;
  double sensor(int index) const;
  void set_sensor(int index, double value);
  void add_sensor(double value);
  const ::google::protobuf::RepeatedField<double>& sensor() const;
  ::google::protobuf::RepeatedField<double>* mutable_sensor();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_sensor() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_sensor();

  public:
  // optional int32 mode = 3;
  bool has_mode() const;
  void clear_mode() ;
  ::int32_t mode() const;
  void set_mode(::int32_t value);

  private:
  ::int32_t _internal_mode() const;
  void _internal_set_mode(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:filter.UpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> ctrl_;
    ::google::protobuf::RepeatedField<double> sensor_;
    ::int32_t mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class State final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.State) */ {
 public:
  inline State() : State(nullptr) {}
  ~State() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR State(::google::protobuf::internal::ConstantInitialized);

  inline State(const State& from)
      : State(nullptr, from) {}
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const State& default_instance() {
    return *internal_default_instance();
  }
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  State* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<State>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const State& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const State& from) {
    State::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(State* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.State";
  }
  protected:
  explicit State(::google::protobuf::Arena* arena);
  State(::google::protobuf::Arena* arena, const State& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kQfrcFieldNumber = 3,
    kTimeFieldNumber = 2,
  };
  // repeated double state = 1 [packed = true];
  int state_size() const;
  private:
  int _internal_state_size() const;

  public:
  void clear_state() ;
  double state(int index) const;
  void set_state(int index, double value);
  void add_state(double value);
  const ::google::protobuf::RepeatedField<double>& state() const;
  ::google::protobuf::RepeatedField<double>* mutable_state();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_state() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_state();

  public:
  // repeated double qfrc = 3 [packed = true];
  int qfrc_size() const;
  private:
  int _internal_qfrc_size() const;

  public:
  void clear_qfrc() ;
  double qfrc(int index) const;
  void set_qfrc(int index, double value);
  void add_qfrc(double value);
  const ::google::protobuf::RepeatedField<double>& qfrc() const;
  ::google::protobuf::RepeatedField<double>* mutable_qfrc();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_qfrc() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_qfrc();

  public:
  // optional double time = 2;
  bool has_time() const;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:filter.State)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> state_;
    ::google::protobuf::RepeatedField<double> qfrc_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class ResetResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:filter.ResetResponse) */ {
 public:
  inline ResetResponse() : ResetResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResetResponse(::google::protobuf::internal::ConstantInitialized);

  inline ResetResponse(const ResetResponse& from)
      : ResetResponse(nullptr, from) {}
  ResetResponse(ResetResponse&& from) noexcept
    : ResetResponse() {
    *this = ::std::move(from);
  }

  inline ResetResponse& operator=(const ResetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetResponse& operator=(ResetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetResponse* internal_default_instance() {
    return reinterpret_cast<const ResetResponse*>(
               &_ResetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ResetResponse& a, ResetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.ResetResponse";
  }
  protected:
  explicit ResetResponse(::google::protobuf::Arena* arena);
  ResetResponse(::google::protobuf::Arena* arena, const ResetResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:filter.ResetResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class ResetRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:filter.ResetRequest) */ {
 public:
  inline ResetRequest() : ResetRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResetRequest(::google::protobuf::internal::ConstantInitialized);

  inline ResetRequest(const ResetRequest& from)
      : ResetRequest(nullptr, from) {}
  ResetRequest(ResetRequest&& from) noexcept
    : ResetRequest() {
    *this = ::std::move(from);
  }

  inline ResetRequest& operator=(const ResetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetRequest& operator=(ResetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetRequest* internal_default_instance() {
    return reinterpret_cast<const ResetRequest*>(
               &_ResetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResetRequest& a, ResetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.ResetRequest";
  }
  protected:
  explicit ResetRequest(::google::protobuf::Arena* arena);
  ResetRequest(::google::protobuf::Arena* arena, const ResetRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:filter.ResetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class Noise final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.Noise) */ {
 public:
  inline Noise() : Noise(nullptr) {}
  ~Noise() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Noise(::google::protobuf::internal::ConstantInitialized);

  inline Noise(const Noise& from)
      : Noise(nullptr, from) {}
  Noise(Noise&& from) noexcept
    : Noise() {
    *this = ::std::move(from);
  }

  inline Noise& operator=(const Noise& from) {
    CopyFrom(from);
    return *this;
  }
  inline Noise& operator=(Noise&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Noise& default_instance() {
    return *internal_default_instance();
  }
  static inline const Noise* internal_default_instance() {
    return reinterpret_cast<const Noise*>(
               &_Noise_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Noise& a, Noise& b) {
    a.Swap(&b);
  }
  inline void Swap(Noise* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Noise* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Noise* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Noise>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Noise& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Noise& from) {
    Noise::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Noise* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.Noise";
  }
  protected:
  explicit Noise(::google::protobuf::Arena* arena);
  Noise(::google::protobuf::Arena* arena, const Noise& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessFieldNumber = 1,
    kSensorFieldNumber = 2,
  };
  // repeated double process = 1 [packed = true];
  int process_size() const;
  private:
  int _internal_process_size() const;

  public:
  void clear_process() ;
  double process(int index) const;
  void set_process(int index, double value);
  void add_process(double value);
  const ::google::protobuf::RepeatedField<double>& process() const;
  ::google::protobuf::RepeatedField<double>* mutable_process();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_process() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_process();

  public:
  // repeated double sensor = 2 [packed = true];
  int sensor_size() const;
  private:
  int _internal_sensor_size() const;

  public:
  void clear_sensor() ;
  double sensor(int index) const;
  void set_sensor(int index, double value);
  void add_sensor(double value);
  const ::google::protobuf::RepeatedField<double>& sensor() const;
  ::google::protobuf::RepeatedField<double>* mutable_sensor();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_sensor() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_sensor();

  public:
  // @@protoc_insertion_point(class_scope:filter.Noise)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> process_;
    ::google::protobuf::RepeatedField<double> sensor_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class MjModel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.MjModel) */ {
 public:
  inline MjModel() : MjModel(nullptr) {}
  ~MjModel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MjModel(::google::protobuf::internal::ConstantInitialized);

  inline MjModel(const MjModel& from)
      : MjModel(nullptr, from) {}
  MjModel(MjModel&& from) noexcept
    : MjModel() {
    *this = ::std::move(from);
  }

  inline MjModel& operator=(const MjModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline MjModel& operator=(MjModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MjModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const MjModel* internal_default_instance() {
    return reinterpret_cast<const MjModel*>(
               &_MjModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MjModel& a, MjModel& b) {
    a.Swap(&b);
  }
  inline void Swap(MjModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MjModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MjModel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MjModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MjModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MjModel& from) {
    MjModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MjModel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.MjModel";
  }
  protected:
  explicit MjModel(::google::protobuf::Arena* arena);
  MjModel(::google::protobuf::Arena* arena, const MjModel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMjbFieldNumber = 1,
    kXmlFieldNumber = 2,
  };
  // optional bytes mjb = 1;
  bool has_mjb() const;
  void clear_mjb() ;
  const std::string& mjb() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mjb(Arg_&& arg, Args_... args);
  std::string* mutable_mjb();
  PROTOBUF_NODISCARD std::string* release_mjb();
  void set_allocated_mjb(std::string* value);

  private:
  const std::string& _internal_mjb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mjb(
      const std::string& value);
  std::string* _internal_mutable_mjb();

  public:
  // optional string xml = 2;
  bool has_xml() const;
  void clear_xml() ;
  const std::string& xml() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_xml(Arg_&& arg, Args_... args);
  std::string* mutable_xml();
  PROTOBUF_NODISCARD std::string* release_xml();
  void set_allocated_xml(std::string* value);

  private:
  const std::string& _internal_xml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xml(
      const std::string& value);
  std::string* _internal_mutable_xml();

  public:
  // @@protoc_insertion_point(class_scope:filter.MjModel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      26, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr mjb_;
    ::google::protobuf::internal::ArenaStringPtr xml_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class InitResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:filter.InitResponse) */ {
 public:
  inline InitResponse() : InitResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InitResponse(::google::protobuf::internal::ConstantInitialized);

  inline InitResponse(const InitResponse& from)
      : InitResponse(nullptr, from) {}
  InitResponse(InitResponse&& from) noexcept
    : InitResponse() {
    *this = ::std::move(from);
  }

  inline InitResponse& operator=(const InitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitResponse& operator=(InitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitResponse* internal_default_instance() {
    return reinterpret_cast<const InitResponse*>(
               &_InitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InitResponse& a, InitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.InitResponse";
  }
  protected:
  explicit InitResponse(::google::protobuf::Arena* arena);
  InitResponse(::google::protobuf::Arena* arena, const InitResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:filter.InitResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class Covariance final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.Covariance) */ {
 public:
  inline Covariance() : Covariance(nullptr) {}
  ~Covariance() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Covariance(::google::protobuf::internal::ConstantInitialized);

  inline Covariance(const Covariance& from)
      : Covariance(nullptr, from) {}
  Covariance(Covariance&& from) noexcept
    : Covariance() {
    *this = ::std::move(from);
  }

  inline Covariance& operator=(const Covariance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Covariance& operator=(Covariance&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Covariance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Covariance* internal_default_instance() {
    return reinterpret_cast<const Covariance*>(
               &_Covariance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Covariance& a, Covariance& b) {
    a.Swap(&b);
  }
  inline void Swap(Covariance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Covariance* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Covariance* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Covariance>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Covariance& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Covariance& from) {
    Covariance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Covariance* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.Covariance";
  }
  protected:
  explicit Covariance(::google::protobuf::Arena* arena);
  Covariance(::google::protobuf::Arena* arena, const Covariance& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCovarianceFieldNumber = 1,
    kDimensionFieldNumber = 2,
  };
  // repeated double covariance = 1 [packed = true];
  int covariance_size() const;
  private:
  int _internal_covariance_size() const;

  public:
  void clear_covariance() ;
  double covariance(int index) const;
  void set_covariance(int index, double value);
  void add_covariance(double value);
  const ::google::protobuf::RepeatedField<double>& covariance() const;
  ::google::protobuf::RepeatedField<double>* mutable_covariance();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_covariance() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_covariance();

  public:
  // optional int32 dimension = 2;
  bool has_dimension() const;
  void clear_dimension() ;
  ::int32_t dimension() const;
  void set_dimension(::int32_t value);

  private:
  ::int32_t _internal_dimension() const;
  void _internal_set_dimension(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:filter.Covariance)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> covariance_;
    ::int32_t dimension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class StateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.StateResponse) */ {
 public:
  inline StateResponse() : StateResponse(nullptr) {}
  ~StateResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StateResponse(::google::protobuf::internal::ConstantInitialized);

  inline StateResponse(const StateResponse& from)
      : StateResponse(nullptr, from) {}
  StateResponse(StateResponse&& from) noexcept
    : StateResponse() {
    *this = ::std::move(from);
  }

  inline StateResponse& operator=(const StateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateResponse& operator=(StateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateResponse* internal_default_instance() {
    return reinterpret_cast<const StateResponse*>(
               &_StateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StateResponse& a, StateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StateResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StateResponse& from) {
    StateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StateResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.StateResponse";
  }
  protected:
  explicit StateResponse(::google::protobuf::Arena* arena);
  StateResponse(::google::protobuf::Arena* arena, const StateResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .filter.State state = 1;
  bool has_state() const;
  void clear_state() ;
  const ::filter::State& state() const;
  PROTOBUF_NODISCARD ::filter::State* release_state();
  ::filter::State* mutable_state();
  void set_allocated_state(::filter::State* value);
  void unsafe_arena_set_allocated_state(::filter::State* value);
  ::filter::State* unsafe_arena_release_state();

  private:
  const ::filter::State& _internal_state() const;
  ::filter::State* _internal_mutable_state();

  public:
  // @@protoc_insertion_point(class_scope:filter.StateResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::filter::State* state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class StateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.StateRequest) */ {
 public:
  inline StateRequest() : StateRequest(nullptr) {}
  ~StateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StateRequest(::google::protobuf::internal::ConstantInitialized);

  inline StateRequest(const StateRequest& from)
      : StateRequest(nullptr, from) {}
  StateRequest(StateRequest&& from) noexcept
    : StateRequest() {
    *this = ::std::move(from);
  }

  inline StateRequest& operator=(const StateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateRequest& operator=(StateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateRequest* internal_default_instance() {
    return reinterpret_cast<const StateRequest*>(
               &_StateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StateRequest& a, StateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StateRequest& from) {
    StateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.StateRequest";
  }
  protected:
  explicit StateRequest(::google::protobuf::Arena* arena);
  StateRequest(::google::protobuf::Arena* arena, const StateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .filter.State state = 1;
  bool has_state() const;
  void clear_state() ;
  const ::filter::State& state() const;
  PROTOBUF_NODISCARD ::filter::State* release_state();
  ::filter::State* mutable_state();
  void set_allocated_state(::filter::State* value);
  void unsafe_arena_set_allocated_state(::filter::State* value);
  ::filter::State* unsafe_arena_release_state();

  private:
  const ::filter::State& _internal_state() const;
  ::filter::State* _internal_mutable_state();

  public:
  // @@protoc_insertion_point(class_scope:filter.StateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::filter::State* state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class NoiseResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.NoiseResponse) */ {
 public:
  inline NoiseResponse() : NoiseResponse(nullptr) {}
  ~NoiseResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoiseResponse(::google::protobuf::internal::ConstantInitialized);

  inline NoiseResponse(const NoiseResponse& from)
      : NoiseResponse(nullptr, from) {}
  NoiseResponse(NoiseResponse&& from) noexcept
    : NoiseResponse() {
    *this = ::std::move(from);
  }

  inline NoiseResponse& operator=(const NoiseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoiseResponse& operator=(NoiseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoiseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoiseResponse* internal_default_instance() {
    return reinterpret_cast<const NoiseResponse*>(
               &_NoiseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NoiseResponse& a, NoiseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NoiseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoiseResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoiseResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoiseResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoiseResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoiseResponse& from) {
    NoiseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoiseResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.NoiseResponse";
  }
  protected:
  explicit NoiseResponse(::google::protobuf::Arena* arena);
  NoiseResponse(::google::protobuf::Arena* arena, const NoiseResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoiseFieldNumber = 1,
  };
  // .filter.Noise noise = 1;
  bool has_noise() const;
  void clear_noise() ;
  const ::filter::Noise& noise() const;
  PROTOBUF_NODISCARD ::filter::Noise* release_noise();
  ::filter::Noise* mutable_noise();
  void set_allocated_noise(::filter::Noise* value);
  void unsafe_arena_set_allocated_noise(::filter::Noise* value);
  ::filter::Noise* unsafe_arena_release_noise();

  private:
  const ::filter::Noise& _internal_noise() const;
  ::filter::Noise* _internal_mutable_noise();

  public:
  // @@protoc_insertion_point(class_scope:filter.NoiseResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::filter::Noise* noise_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class NoiseRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.NoiseRequest) */ {
 public:
  inline NoiseRequest() : NoiseRequest(nullptr) {}
  ~NoiseRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NoiseRequest(::google::protobuf::internal::ConstantInitialized);

  inline NoiseRequest(const NoiseRequest& from)
      : NoiseRequest(nullptr, from) {}
  NoiseRequest(NoiseRequest&& from) noexcept
    : NoiseRequest() {
    *this = ::std::move(from);
  }

  inline NoiseRequest& operator=(const NoiseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoiseRequest& operator=(NoiseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoiseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoiseRequest* internal_default_instance() {
    return reinterpret_cast<const NoiseRequest*>(
               &_NoiseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NoiseRequest& a, NoiseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NoiseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoiseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoiseRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoiseRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoiseRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NoiseRequest& from) {
    NoiseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NoiseRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.NoiseRequest";
  }
  protected:
  explicit NoiseRequest(::google::protobuf::Arena* arena);
  NoiseRequest(::google::protobuf::Arena* arena, const NoiseRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoiseFieldNumber = 1,
  };
  // .filter.Noise noise = 1;
  bool has_noise() const;
  void clear_noise() ;
  const ::filter::Noise& noise() const;
  PROTOBUF_NODISCARD ::filter::Noise* release_noise();
  ::filter::Noise* mutable_noise();
  void set_allocated_noise(::filter::Noise* value);
  void unsafe_arena_set_allocated_noise(::filter::Noise* value);
  ::filter::Noise* unsafe_arena_release_noise();

  private:
  const ::filter::Noise& _internal_noise() const;
  ::filter::Noise* _internal_mutable_noise();

  public:
  // @@protoc_insertion_point(class_scope:filter.NoiseRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::filter::Noise* noise_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class InitRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.InitRequest) */ {
 public:
  inline InitRequest() : InitRequest(nullptr) {}
  ~InitRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InitRequest(::google::protobuf::internal::ConstantInitialized);

  inline InitRequest(const InitRequest& from)
      : InitRequest(nullptr, from) {}
  InitRequest(InitRequest&& from) noexcept
    : InitRequest() {
    *this = ::std::move(from);
  }

  inline InitRequest& operator=(const InitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitRequest& operator=(InitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitRequest* internal_default_instance() {
    return reinterpret_cast<const InitRequest*>(
               &_InitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InitRequest& a, InitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InitRequest& from) {
    InitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InitRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.InitRequest";
  }
  protected:
  explicit InitRequest(::google::protobuf::Arena* arena);
  InitRequest(::google::protobuf::Arena* arena, const InitRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
  };
  // optional .filter.MjModel model = 1;
  bool has_model() const;
  void clear_model() ;
  const ::filter::MjModel& model() const;
  PROTOBUF_NODISCARD ::filter::MjModel* release_model();
  ::filter::MjModel* mutable_model();
  void set_allocated_model(::filter::MjModel* value);
  void unsafe_arena_set_allocated_model(::filter::MjModel* value);
  ::filter::MjModel* unsafe_arena_release_model();

  private:
  const ::filter::MjModel& _internal_model() const;
  ::filter::MjModel* _internal_mutable_model();

  public:
  // @@protoc_insertion_point(class_scope:filter.InitRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::filter::MjModel* model_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class CovarianceResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.CovarianceResponse) */ {
 public:
  inline CovarianceResponse() : CovarianceResponse(nullptr) {}
  ~CovarianceResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CovarianceResponse(::google::protobuf::internal::ConstantInitialized);

  inline CovarianceResponse(const CovarianceResponse& from)
      : CovarianceResponse(nullptr, from) {}
  CovarianceResponse(CovarianceResponse&& from) noexcept
    : CovarianceResponse() {
    *this = ::std::move(from);
  }

  inline CovarianceResponse& operator=(const CovarianceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CovarianceResponse& operator=(CovarianceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CovarianceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CovarianceResponse* internal_default_instance() {
    return reinterpret_cast<const CovarianceResponse*>(
               &_CovarianceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CovarianceResponse& a, CovarianceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CovarianceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CovarianceResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CovarianceResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CovarianceResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CovarianceResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CovarianceResponse& from) {
    CovarianceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CovarianceResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.CovarianceResponse";
  }
  protected:
  explicit CovarianceResponse(::google::protobuf::Arena* arena);
  CovarianceResponse(::google::protobuf::Arena* arena, const CovarianceResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCovarianceFieldNumber = 1,
  };
  // .filter.Covariance covariance = 1;
  bool has_covariance() const;
  void clear_covariance() ;
  const ::filter::Covariance& covariance() const;
  PROTOBUF_NODISCARD ::filter::Covariance* release_covariance();
  ::filter::Covariance* mutable_covariance();
  void set_allocated_covariance(::filter::Covariance* value);
  void unsafe_arena_set_allocated_covariance(::filter::Covariance* value);
  ::filter::Covariance* unsafe_arena_release_covariance();

  private:
  const ::filter::Covariance& _internal_covariance() const;
  ::filter::Covariance* _internal_mutable_covariance();

  public:
  // @@protoc_insertion_point(class_scope:filter.CovarianceResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::filter::Covariance* covariance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};// -------------------------------------------------------------------

class CovarianceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:filter.CovarianceRequest) */ {
 public:
  inline CovarianceRequest() : CovarianceRequest(nullptr) {}
  ~CovarianceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CovarianceRequest(::google::protobuf::internal::ConstantInitialized);

  inline CovarianceRequest(const CovarianceRequest& from)
      : CovarianceRequest(nullptr, from) {}
  CovarianceRequest(CovarianceRequest&& from) noexcept
    : CovarianceRequest() {
    *this = ::std::move(from);
  }

  inline CovarianceRequest& operator=(const CovarianceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CovarianceRequest& operator=(CovarianceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CovarianceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CovarianceRequest* internal_default_instance() {
    return reinterpret_cast<const CovarianceRequest*>(
               &_CovarianceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CovarianceRequest& a, CovarianceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CovarianceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CovarianceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CovarianceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CovarianceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CovarianceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CovarianceRequest& from) {
    CovarianceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CovarianceRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "filter.CovarianceRequest";
  }
  protected:
  explicit CovarianceRequest(::google::protobuf::Arena* arena);
  CovarianceRequest(::google::protobuf::Arena* arena, const CovarianceRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCovarianceFieldNumber = 1,
  };
  // .filter.Covariance covariance = 1;
  bool has_covariance() const;
  void clear_covariance() ;
  const ::filter::Covariance& covariance() const;
  PROTOBUF_NODISCARD ::filter::Covariance* release_covariance();
  ::filter::Covariance* mutable_covariance();
  void set_allocated_covariance(::filter::Covariance* value);
  void unsafe_arena_set_allocated_covariance(::filter::Covariance* value);
  ::filter::Covariance* unsafe_arena_release_covariance();

  private:
  const ::filter::Covariance& _internal_covariance() const;
  ::filter::Covariance* _internal_mutable_covariance();

  public:
  // @@protoc_insertion_point(class_scope:filter.CovarianceRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::filter::Covariance* covariance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_filter_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MjModel

// optional bytes mjb = 1;
inline bool MjModel::has_mjb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MjModel::clear_mjb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mjb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MjModel::mjb() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:filter.MjModel.mjb)
  return _internal_mjb();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MjModel::set_mjb(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mjb_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:filter.MjModel.mjb)
}
inline std::string* MjModel::mutable_mjb() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mjb();
  // @@protoc_insertion_point(field_mutable:filter.MjModel.mjb)
  return _s;
}
inline const std::string& MjModel::_internal_mjb() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mjb_.Get();
}
inline void MjModel::_internal_set_mjb(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mjb_.Set(value, GetArena());
}
inline std::string* MjModel::_internal_mutable_mjb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mjb_.Mutable( GetArena());
}
inline std::string* MjModel::release_mjb() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:filter.MjModel.mjb)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.mjb_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mjb_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MjModel::set_allocated_mjb(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mjb_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mjb_.IsDefault()) {
          _impl_.mjb_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:filter.MjModel.mjb)
}

// optional string xml = 2;
inline bool MjModel::has_xml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MjModel::clear_xml() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.xml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MjModel::xml() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:filter.MjModel.xml)
  return _internal_xml();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MjModel::set_xml(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.xml_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:filter.MjModel.xml)
}
inline std::string* MjModel::mutable_xml() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_xml();
  // @@protoc_insertion_point(field_mutable:filter.MjModel.xml)
  return _s;
}
inline const std::string& MjModel::_internal_xml() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.xml_.Get();
}
inline void MjModel::_internal_set_xml(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.xml_.Set(value, GetArena());
}
inline std::string* MjModel::_internal_mutable_xml() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.xml_.Mutable( GetArena());
}
inline std::string* MjModel::release_xml() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:filter.MjModel.xml)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.xml_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.xml_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MjModel::set_allocated_xml(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.xml_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.xml_.IsDefault()) {
          _impl_.xml_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:filter.MjModel.xml)
}

// -------------------------------------------------------------------

// InitRequest

// optional .filter.MjModel model = 1;
inline bool InitRequest::has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
  return value;
}
inline void InitRequest::clear_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.model_ != nullptr) _impl_.model_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::filter::MjModel& InitRequest::_internal_model() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::filter::MjModel* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::filter::MjModel&>(::filter::_MjModel_default_instance_);
}
inline const ::filter::MjModel& InitRequest::model() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:filter.InitRequest.model)
  return _internal_model();
}
inline void InitRequest::unsafe_arena_set_allocated_model(::filter::MjModel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = reinterpret_cast<::filter::MjModel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filter.InitRequest.model)
}
inline ::filter::MjModel* InitRequest::release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::MjModel* released = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::filter::MjModel* InitRequest::unsafe_arena_release_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:filter.InitRequest.model)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::MjModel* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::filter::MjModel* InitRequest::_internal_mutable_model() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::filter::MjModel>(GetArena());
    _impl_.model_ = reinterpret_cast<::filter::MjModel*>(p);
  }
  return _impl_.model_;
}
inline ::filter::MjModel* InitRequest::mutable_model() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::filter::MjModel* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:filter.InitRequest.model)
  return _msg;
}
inline void InitRequest::set_allocated_model(::filter::MjModel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::filter::MjModel*>(_impl_.model_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::filter::MjModel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.model_ = reinterpret_cast<::filter::MjModel*>(value);
  // @@protoc_insertion_point(field_set_allocated:filter.InitRequest.model)
}

// -------------------------------------------------------------------

// InitResponse

// -------------------------------------------------------------------

// ResetRequest

// -------------------------------------------------------------------

// ResetResponse

// -------------------------------------------------------------------

// UpdateRequest

// repeated double ctrl = 1 [packed = true];
inline int UpdateRequest::_internal_ctrl_size() const {
  return _internal_ctrl().size();
}
inline int UpdateRequest::ctrl_size() const {
  return _internal_ctrl_size();
}
inline void UpdateRequest::clear_ctrl() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ctrl_.Clear();
}
inline double UpdateRequest::ctrl(int index) const {
  // @@protoc_insertion_point(field_get:filter.UpdateRequest.ctrl)
  return _internal_ctrl().Get(index);
}
inline void UpdateRequest::set_ctrl(int index, double value) {
  _internal_mutable_ctrl()->Set(index, value);
  // @@protoc_insertion_point(field_set:filter.UpdateRequest.ctrl)
}
inline void UpdateRequest::add_ctrl(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ctrl()->Add(value);
  // @@protoc_insertion_point(field_add:filter.UpdateRequest.ctrl)
}
inline const ::google::protobuf::RepeatedField<double>& UpdateRequest::ctrl() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:filter.UpdateRequest.ctrl)
  return _internal_ctrl();
}
inline ::google::protobuf::RepeatedField<double>* UpdateRequest::mutable_ctrl()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:filter.UpdateRequest.ctrl)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ctrl();
}
inline const ::google::protobuf::RepeatedField<double>& UpdateRequest::_internal_ctrl()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ctrl_;
}
inline ::google::protobuf::RepeatedField<double>* UpdateRequest::_internal_mutable_ctrl() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ctrl_;
}

// repeated double sensor = 2 [packed = true];
inline int UpdateRequest::_internal_sensor_size() const {
  return _internal_sensor().size();
}
inline int UpdateRequest::sensor_size() const {
  return _internal_sensor_size();
}
inline void UpdateRequest::clear_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_.Clear();
}
inline double UpdateRequest::sensor(int index) const {
  // @@protoc_insertion_point(field_get:filter.UpdateRequest.sensor)
  return _internal_sensor().Get(index);
}
inline void UpdateRequest::set_sensor(int index, double value) {
  _internal_mutable_sensor()->Set(index, value);
  // @@protoc_insertion_point(field_set:filter.UpdateRequest.sensor)
}
inline void UpdateRequest::add_sensor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sensor()->Add(value);
  // @@protoc_insertion_point(field_add:filter.UpdateRequest.sensor)
}
inline const ::google::protobuf::RepeatedField<double>& UpdateRequest::sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:filter.UpdateRequest.sensor)
  return _internal_sensor();
}
inline ::google::protobuf::RepeatedField<double>* UpdateRequest::mutable_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:filter.UpdateRequest.sensor)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sensor();
}
inline const ::google::protobuf::RepeatedField<double>& UpdateRequest::_internal_sensor()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_;
}
inline ::google::protobuf::RepeatedField<double>* UpdateRequest::_internal_mutable_sensor() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sensor_;
}

// optional int32 mode = 3;
inline bool UpdateRequest::has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UpdateRequest::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t UpdateRequest::mode() const {
  // @@protoc_insertion_point(field_get:filter.UpdateRequest.mode)
  return _internal_mode();
}
inline void UpdateRequest::set_mode(::int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:filter.UpdateRequest.mode)
}
inline ::int32_t UpdateRequest::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mode_;
}
inline void UpdateRequest::_internal_set_mode(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mode_ = value;
}

// -------------------------------------------------------------------

// UpdateResponse

// -------------------------------------------------------------------

// State

// repeated double state = 1 [packed = true];
inline int State::_internal_state_size() const {
  return _internal_state().size();
}
inline int State::state_size() const {
  return _internal_state_size();
}
inline void State::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_.Clear();
}
inline double State::state(int index) const {
  // @@protoc_insertion_point(field_get:filter.State.state)
  return _internal_state().Get(index);
}
inline void State::set_state(int index, double value) {
  _internal_mutable_state()->Set(index, value);
  // @@protoc_insertion_point(field_set:filter.State.state)
}
inline void State::add_state(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_state()->Add(value);
  // @@protoc_insertion_point(field_add:filter.State.state)
}
inline const ::google::protobuf::RepeatedField<double>& State::state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:filter.State.state)
  return _internal_state();
}
inline ::google::protobuf::RepeatedField<double>* State::mutable_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:filter.State.state)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_state();
}
inline const ::google::protobuf::RepeatedField<double>& State::_internal_state()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline ::google::protobuf::RepeatedField<double>* State::_internal_mutable_state() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.state_;
}

// optional double time = 2;
inline bool State::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void State::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double State::time() const {
  // @@protoc_insertion_point(field_get:filter.State.time)
  return _internal_time();
}
inline void State::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:filter.State.time)
}
inline double State::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void State::_internal_set_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.time_ = value;
}

// repeated double qfrc = 3 [packed = true];
inline int State::_internal_qfrc_size() const {
  return _internal_qfrc().size();
}
inline int State::qfrc_size() const {
  return _internal_qfrc_size();
}
inline void State::clear_qfrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.qfrc_.Clear();
}
inline double State::qfrc(int index) const {
  // @@protoc_insertion_point(field_get:filter.State.qfrc)
  return _internal_qfrc().Get(index);
}
inline void State::set_qfrc(int index, double value) {
  _internal_mutable_qfrc()->Set(index, value);
  // @@protoc_insertion_point(field_set:filter.State.qfrc)
}
inline void State::add_qfrc(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_qfrc()->Add(value);
  // @@protoc_insertion_point(field_add:filter.State.qfrc)
}
inline const ::google::protobuf::RepeatedField<double>& State::qfrc() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:filter.State.qfrc)
  return _internal_qfrc();
}
inline ::google::protobuf::RepeatedField<double>* State::mutable_qfrc()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:filter.State.qfrc)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_qfrc();
}
inline const ::google::protobuf::RepeatedField<double>& State::_internal_qfrc()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.qfrc_;
}
inline ::google::protobuf::RepeatedField<double>* State::_internal_mutable_qfrc() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.qfrc_;
}

// -------------------------------------------------------------------

// StateRequest

// .filter.State state = 1;
inline bool StateRequest::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void StateRequest::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::filter::State& StateRequest::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::filter::State* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::filter::State&>(::filter::_State_default_instance_);
}
inline const ::filter::State& StateRequest::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:filter.StateRequest.state)
  return _internal_state();
}
inline void StateRequest::unsafe_arena_set_allocated_state(::filter::State* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::filter::State*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filter.StateRequest.state)
}
inline ::filter::State* StateRequest::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::State* released = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::filter::State* StateRequest::unsafe_arena_release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:filter.StateRequest.state)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::State* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::filter::State* StateRequest::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::filter::State>(GetArena());
    _impl_.state_ = reinterpret_cast<::filter::State*>(p);
  }
  return _impl_.state_;
}
inline ::filter::State* StateRequest::mutable_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::filter::State* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:filter.StateRequest.state)
  return _msg;
}
inline void StateRequest::set_allocated_state(::filter::State* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::filter::State*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::filter::State*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.state_ = reinterpret_cast<::filter::State*>(value);
  // @@protoc_insertion_point(field_set_allocated:filter.StateRequest.state)
}

// -------------------------------------------------------------------

// StateResponse

// .filter.State state = 1;
inline bool StateResponse::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void StateResponse::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::filter::State& StateResponse::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::filter::State* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::filter::State&>(::filter::_State_default_instance_);
}
inline const ::filter::State& StateResponse::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:filter.StateResponse.state)
  return _internal_state();
}
inline void StateResponse::unsafe_arena_set_allocated_state(::filter::State* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::filter::State*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filter.StateResponse.state)
}
inline ::filter::State* StateResponse::release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::State* released = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::filter::State* StateResponse::unsafe_arena_release_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:filter.StateResponse.state)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::State* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::filter::State* StateResponse::_internal_mutable_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::filter::State>(GetArena());
    _impl_.state_ = reinterpret_cast<::filter::State*>(p);
  }
  return _impl_.state_;
}
inline ::filter::State* StateResponse::mutable_state() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::filter::State* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:filter.StateResponse.state)
  return _msg;
}
inline void StateResponse::set_allocated_state(::filter::State* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::filter::State*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::filter::State*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.state_ = reinterpret_cast<::filter::State*>(value);
  // @@protoc_insertion_point(field_set_allocated:filter.StateResponse.state)
}

// -------------------------------------------------------------------

// Covariance

// repeated double covariance = 1 [packed = true];
inline int Covariance::_internal_covariance_size() const {
  return _internal_covariance().size();
}
inline int Covariance::covariance_size() const {
  return _internal_covariance_size();
}
inline void Covariance::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.covariance_.Clear();
}
inline double Covariance::covariance(int index) const {
  // @@protoc_insertion_point(field_get:filter.Covariance.covariance)
  return _internal_covariance().Get(index);
}
inline void Covariance::set_covariance(int index, double value) {
  _internal_mutable_covariance()->Set(index, value);
  // @@protoc_insertion_point(field_set:filter.Covariance.covariance)
}
inline void Covariance::add_covariance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_covariance()->Add(value);
  // @@protoc_insertion_point(field_add:filter.Covariance.covariance)
}
inline const ::google::protobuf::RepeatedField<double>& Covariance::covariance() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:filter.Covariance.covariance)
  return _internal_covariance();
}
inline ::google::protobuf::RepeatedField<double>* Covariance::mutable_covariance()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:filter.Covariance.covariance)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_covariance();
}
inline const ::google::protobuf::RepeatedField<double>& Covariance::_internal_covariance()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.covariance_;
}
inline ::google::protobuf::RepeatedField<double>* Covariance::_internal_mutable_covariance() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.covariance_;
}

// optional int32 dimension = 2;
inline bool Covariance::has_dimension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Covariance::clear_dimension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dimension_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Covariance::dimension() const {
  // @@protoc_insertion_point(field_get:filter.Covariance.dimension)
  return _internal_dimension();
}
inline void Covariance::set_dimension(::int32_t value) {
  _internal_set_dimension(value);
  // @@protoc_insertion_point(field_set:filter.Covariance.dimension)
}
inline ::int32_t Covariance::_internal_dimension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dimension_;
}
inline void Covariance::_internal_set_dimension(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dimension_ = value;
}

// -------------------------------------------------------------------

// CovarianceRequest

// .filter.Covariance covariance = 1;
inline bool CovarianceRequest::has_covariance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.covariance_ != nullptr);
  return value;
}
inline void CovarianceRequest::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.covariance_ != nullptr) _impl_.covariance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::filter::Covariance& CovarianceRequest::_internal_covariance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::filter::Covariance* p = _impl_.covariance_;
  return p != nullptr ? *p : reinterpret_cast<const ::filter::Covariance&>(::filter::_Covariance_default_instance_);
}
inline const ::filter::Covariance& CovarianceRequest::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:filter.CovarianceRequest.covariance)
  return _internal_covariance();
}
inline void CovarianceRequest::unsafe_arena_set_allocated_covariance(::filter::Covariance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.covariance_);
  }
  _impl_.covariance_ = reinterpret_cast<::filter::Covariance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filter.CovarianceRequest.covariance)
}
inline ::filter::Covariance* CovarianceRequest::release_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::Covariance* released = _impl_.covariance_;
  _impl_.covariance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::filter::Covariance* CovarianceRequest::unsafe_arena_release_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:filter.CovarianceRequest.covariance)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::Covariance* temp = _impl_.covariance_;
  _impl_.covariance_ = nullptr;
  return temp;
}
inline ::filter::Covariance* CovarianceRequest::_internal_mutable_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.covariance_ == nullptr) {
    auto* p = CreateMaybeMessage<::filter::Covariance>(GetArena());
    _impl_.covariance_ = reinterpret_cast<::filter::Covariance*>(p);
  }
  return _impl_.covariance_;
}
inline ::filter::Covariance* CovarianceRequest::mutable_covariance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::filter::Covariance* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:filter.CovarianceRequest.covariance)
  return _msg;
}
inline void CovarianceRequest::set_allocated_covariance(::filter::Covariance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::filter::Covariance*>(_impl_.covariance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::filter::Covariance*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.covariance_ = reinterpret_cast<::filter::Covariance*>(value);
  // @@protoc_insertion_point(field_set_allocated:filter.CovarianceRequest.covariance)
}

// -------------------------------------------------------------------

// CovarianceResponse

// .filter.Covariance covariance = 1;
inline bool CovarianceResponse::has_covariance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.covariance_ != nullptr);
  return value;
}
inline void CovarianceResponse::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.covariance_ != nullptr) _impl_.covariance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::filter::Covariance& CovarianceResponse::_internal_covariance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::filter::Covariance* p = _impl_.covariance_;
  return p != nullptr ? *p : reinterpret_cast<const ::filter::Covariance&>(::filter::_Covariance_default_instance_);
}
inline const ::filter::Covariance& CovarianceResponse::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:filter.CovarianceResponse.covariance)
  return _internal_covariance();
}
inline void CovarianceResponse::unsafe_arena_set_allocated_covariance(::filter::Covariance* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.covariance_);
  }
  _impl_.covariance_ = reinterpret_cast<::filter::Covariance*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filter.CovarianceResponse.covariance)
}
inline ::filter::Covariance* CovarianceResponse::release_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::Covariance* released = _impl_.covariance_;
  _impl_.covariance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::filter::Covariance* CovarianceResponse::unsafe_arena_release_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:filter.CovarianceResponse.covariance)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::Covariance* temp = _impl_.covariance_;
  _impl_.covariance_ = nullptr;
  return temp;
}
inline ::filter::Covariance* CovarianceResponse::_internal_mutable_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.covariance_ == nullptr) {
    auto* p = CreateMaybeMessage<::filter::Covariance>(GetArena());
    _impl_.covariance_ = reinterpret_cast<::filter::Covariance*>(p);
  }
  return _impl_.covariance_;
}
inline ::filter::Covariance* CovarianceResponse::mutable_covariance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::filter::Covariance* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:filter.CovarianceResponse.covariance)
  return _msg;
}
inline void CovarianceResponse::set_allocated_covariance(::filter::Covariance* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::filter::Covariance*>(_impl_.covariance_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::filter::Covariance*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.covariance_ = reinterpret_cast<::filter::Covariance*>(value);
  // @@protoc_insertion_point(field_set_allocated:filter.CovarianceResponse.covariance)
}

// -------------------------------------------------------------------

// Noise

// repeated double process = 1 [packed = true];
inline int Noise::_internal_process_size() const {
  return _internal_process().size();
}
inline int Noise::process_size() const {
  return _internal_process_size();
}
inline void Noise::clear_process() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.process_.Clear();
}
inline double Noise::process(int index) const {
  // @@protoc_insertion_point(field_get:filter.Noise.process)
  return _internal_process().Get(index);
}
inline void Noise::set_process(int index, double value) {
  _internal_mutable_process()->Set(index, value);
  // @@protoc_insertion_point(field_set:filter.Noise.process)
}
inline void Noise::add_process(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_process()->Add(value);
  // @@protoc_insertion_point(field_add:filter.Noise.process)
}
inline const ::google::protobuf::RepeatedField<double>& Noise::process() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:filter.Noise.process)
  return _internal_process();
}
inline ::google::protobuf::RepeatedField<double>* Noise::mutable_process()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:filter.Noise.process)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_process();
}
inline const ::google::protobuf::RepeatedField<double>& Noise::_internal_process()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.process_;
}
inline ::google::protobuf::RepeatedField<double>* Noise::_internal_mutable_process() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.process_;
}

// repeated double sensor = 2 [packed = true];
inline int Noise::_internal_sensor_size() const {
  return _internal_sensor().size();
}
inline int Noise::sensor_size() const {
  return _internal_sensor_size();
}
inline void Noise::clear_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sensor_.Clear();
}
inline double Noise::sensor(int index) const {
  // @@protoc_insertion_point(field_get:filter.Noise.sensor)
  return _internal_sensor().Get(index);
}
inline void Noise::set_sensor(int index, double value) {
  _internal_mutable_sensor()->Set(index, value);
  // @@protoc_insertion_point(field_set:filter.Noise.sensor)
}
inline void Noise::add_sensor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_sensor()->Add(value);
  // @@protoc_insertion_point(field_add:filter.Noise.sensor)
}
inline const ::google::protobuf::RepeatedField<double>& Noise::sensor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:filter.Noise.sensor)
  return _internal_sensor();
}
inline ::google::protobuf::RepeatedField<double>* Noise::mutable_sensor()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:filter.Noise.sensor)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sensor();
}
inline const ::google::protobuf::RepeatedField<double>& Noise::_internal_sensor()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_;
}
inline ::google::protobuf::RepeatedField<double>* Noise::_internal_mutable_sensor() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sensor_;
}

// -------------------------------------------------------------------

// NoiseRequest

// .filter.Noise noise = 1;
inline bool NoiseRequest::has_noise() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.noise_ != nullptr);
  return value;
}
inline void NoiseRequest::clear_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.noise_ != nullptr) _impl_.noise_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::filter::Noise& NoiseRequest::_internal_noise() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::filter::Noise* p = _impl_.noise_;
  return p != nullptr ? *p : reinterpret_cast<const ::filter::Noise&>(::filter::_Noise_default_instance_);
}
inline const ::filter::Noise& NoiseRequest::noise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:filter.NoiseRequest.noise)
  return _internal_noise();
}
inline void NoiseRequest::unsafe_arena_set_allocated_noise(::filter::Noise* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.noise_);
  }
  _impl_.noise_ = reinterpret_cast<::filter::Noise*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filter.NoiseRequest.noise)
}
inline ::filter::Noise* NoiseRequest::release_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::Noise* released = _impl_.noise_;
  _impl_.noise_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::filter::Noise* NoiseRequest::unsafe_arena_release_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:filter.NoiseRequest.noise)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::Noise* temp = _impl_.noise_;
  _impl_.noise_ = nullptr;
  return temp;
}
inline ::filter::Noise* NoiseRequest::_internal_mutable_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.noise_ == nullptr) {
    auto* p = CreateMaybeMessage<::filter::Noise>(GetArena());
    _impl_.noise_ = reinterpret_cast<::filter::Noise*>(p);
  }
  return _impl_.noise_;
}
inline ::filter::Noise* NoiseRequest::mutable_noise() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::filter::Noise* _msg = _internal_mutable_noise();
  // @@protoc_insertion_point(field_mutable:filter.NoiseRequest.noise)
  return _msg;
}
inline void NoiseRequest::set_allocated_noise(::filter::Noise* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::filter::Noise*>(_impl_.noise_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::filter::Noise*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.noise_ = reinterpret_cast<::filter::Noise*>(value);
  // @@protoc_insertion_point(field_set_allocated:filter.NoiseRequest.noise)
}

// -------------------------------------------------------------------

// NoiseResponse

// .filter.Noise noise = 1;
inline bool NoiseResponse::has_noise() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.noise_ != nullptr);
  return value;
}
inline void NoiseResponse::clear_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.noise_ != nullptr) _impl_.noise_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::filter::Noise& NoiseResponse::_internal_noise() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::filter::Noise* p = _impl_.noise_;
  return p != nullptr ? *p : reinterpret_cast<const ::filter::Noise&>(::filter::_Noise_default_instance_);
}
inline const ::filter::Noise& NoiseResponse::noise() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:filter.NoiseResponse.noise)
  return _internal_noise();
}
inline void NoiseResponse::unsafe_arena_set_allocated_noise(::filter::Noise* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.noise_);
  }
  _impl_.noise_ = reinterpret_cast<::filter::Noise*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:filter.NoiseResponse.noise)
}
inline ::filter::Noise* NoiseResponse::release_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::Noise* released = _impl_.noise_;
  _impl_.noise_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::filter::Noise* NoiseResponse::unsafe_arena_release_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:filter.NoiseResponse.noise)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::filter::Noise* temp = _impl_.noise_;
  _impl_.noise_ = nullptr;
  return temp;
}
inline ::filter::Noise* NoiseResponse::_internal_mutable_noise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.noise_ == nullptr) {
    auto* p = CreateMaybeMessage<::filter::Noise>(GetArena());
    _impl_.noise_ = reinterpret_cast<::filter::Noise*>(p);
  }
  return _impl_.noise_;
}
inline ::filter::Noise* NoiseResponse::mutable_noise() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::filter::Noise* _msg = _internal_mutable_noise();
  // @@protoc_insertion_point(field_mutable:filter.NoiseResponse.noise)
  return _msg;
}
inline void NoiseResponse::set_allocated_noise(::filter::Noise* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::filter::Noise*>(_impl_.noise_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::filter::Noise*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.noise_ = reinterpret_cast<::filter::Noise*>(value);
  // @@protoc_insertion_point(field_set_allocated:filter.NoiseResponse.noise)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace filter


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_filter_2eproto_2epb_2eh
